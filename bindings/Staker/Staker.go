// This file was generated by seer: https://github.com/G7DAO/seer.
// seer version: 0.3.15
// seer command: seer evm generate --package Staker --cli --struct Staker --output bindings/Staker/Staker.go
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package Staker

import (
	"bytes"
	"crypto/rand"
	"errors"
	"math/big"
	"net/http"
	"strings"

	"context"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/ethereum/go-ethereum/signer/core/apitypes"

	// Reference imports to suppress errors if they are not otherwise used.
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/G7DAO/seer/bindings/CreateCall"
	"github.com/G7DAO/seer/bindings/GnosisSafe"
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/spf13/cobra"
	"golang.org/x/term"

	// StakerMetaData contains all meta data concerning the Staker contract.
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/crypto"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

var StakerMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"positionMetadata\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721EnumerableForbiddenBatchMint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721IncorrectOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721InsufficientApproval\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC721InvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC721InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC721InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721NonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ERC721OutOfBoundsIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolTokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenTypeArg\",\"type\":\"uint256\"}],\"name\":\"IncorrectTokenType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"name\":\"InitiateUnstakeFirst\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidConfiguration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"LockupNotExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MetadataError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonAdministrator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToStake\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"}],\"name\":\"PositionNotTransferable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"UnauthorizedForPosition\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"name\":\"StakingPoolConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"StakingPoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"UnstakeInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CurrentAmountInPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CurrentPositionsInPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC1155_TOKEN_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC20_TOKEN_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC721_TOKEN_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NATIVE_TOKEN_TYPE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Positions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeInitiatedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalPositions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"administrator\",\"type\":\"address\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"}],\"name\":\"initiateUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"positionMetadataAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"positionHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeERC1155\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"positionHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"positionHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"stakeERC721\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"positionHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"}],\"name\":\"stakeNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newAdministrator\",\"type\":\"address\"}],\"name\":\"transferPoolAdministration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionTokenID\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"changeTransferability\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"transferable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"changeLockup\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupSeconds\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"changeCooldown\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"cooldownSeconds\",\"type\":\"uint256\"}],\"name\":\"updatePoolConfiguration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a060405234801561001057600080fd5b50604051613d17380380613d1783398101604081905261002f916100aa565b6040518060400160405280600c81526020016b23b0b6b29b9029ba30b5b2b960a11b81525060405180604001604052806008815260200167239ba9aa20a5a2a960c11b81525081600090816100849190610179565b5060016100918282610179565b50506001600a55506001600160a01b0316608052610237565b6000602082840312156100bc57600080fd5b81516001600160a01b03811681146100d357600080fd5b9392505050565b634e487b7160e01b600052604160045260246000fd5b600181811c9082168061010457607f821691505b60208210810361012457634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561017457806000526020600020601f840160051c810160208510156101515750805b601f840160051c820191505b81811015610171576000815560010161015d565b50505b505050565b81516001600160401b03811115610192576101926100da565b6101a6816101a084546100f0565b8461012a565b6020601f8211600181146101da57600083156101c25750848201515b600019600385901b1c1916600184901b178455610171565b600084815260208120601f198516915b8281101561020a57878501518255602094850194600190920191016101ea565b50848210156102285786840151600019600387901b60f8161c191681555b50505050600190811b01905550565b608051613abe610259600039600081816108080152611c770152613abe6000f3fe6080604052600436106102845760003560e01c806373dfccca11610153578063b0fe4a7e116100cb578063d693595d1161007f578063e985e9c511610064578063e985e9c51461084a578063f09e76a1146108a0578063f23a6e61146108b657600080fd5b8063d693595d146107f6578063df44bf761461082a57600080fd5b8063b88d4fde116100b0578063b88d4fde146107a1578063c87b56dd146107c1578063d2ba4409146107e157600080fd5b8063b0fe4a7e14610754578063b29087da1461077457600080fd5b806395d89b4111610122578063a22cb46511610107578063a22cb465146106fe578063abd4ce781461071e578063ae5ac9211461073457600080fd5b806395d89b41146106d6578063a1ed8fef146106eb57600080fd5b806373dfccca146105aa57806377bd2e781461067457806381c822e6146106895780638d4a9e85146106b657600080fd5b80632f745c59116102015780634f6ccce7116101b55780636352211e1161019a5780636352211e1461050857806370a082311461052857806373caf0f71461054857600080fd5b80634f6ccce7146104c8578063621519c0146104e857600080fd5b80633db26319116101e65780633db2631914610472578063424b93111461049257806342842e0e146104a857600080fd5b80632f745c591461043c5780633ab0f1c11461045c57600080fd5b8063095ea7b31161025857806318160ddd1161023d57806318160ddd146103dd57806323b872dd146103fc5780632e17de781461041c57600080fd5b8063095ea7b314610347578063150b7a021461036757600080fd5b80627d0cec1461028957806301ffc9a7146102ab57806306fdde03146102e0578063081812fc14610302575b600080fd5b34801561029557600080fd5b506102a96102a4366004613220565b6108fc565b005b3480156102b757600080fd5b506102cb6102c63660046132ca565b610a27565b60405190151581526020015b60405180910390f35b3480156102ec57600080fd5b506102f5610a83565b6040516102d79190613355565b34801561030e57600080fd5b5061032261031d366004613368565b610b15565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016102d7565b34801561035357600080fd5b506102a96103623660046133aa565b610b4b565b34801561037357600080fd5b506103ac61038236600461341d565b7f150b7a020000000000000000000000000000000000000000000000000000000095945050505050565b6040517fffffffff0000000000000000000000000000000000000000000000000000000090911681526020016102d7565b3480156103e957600080fd5b506008545b6040519081526020016102d7565b34801561040857600080fd5b506102a961041736600461348c565b610b5a565b34801561042857600080fd5b506102a9610437366004613368565b610bcf565b34801561044857600080fd5b506103ee6104573660046133aa565b611069565b34801561046857600080fd5b506103ee600c5481565b34801561047e57600080fd5b506102a961048d3660046134c9565b611101565b34801561049e57600080fd5b506103ee600b5481565b3480156104b457600080fd5b506102a96104c336600461348c565b6111fc565b3480156104d457600080fd5b506103ee6104e3366004613368565b61121c565b3480156104f457600080fd5b506103ee6105033660046134f5565b61128e565b34801561051457600080fd5b50610322610523366004613368565b61149c565b34801561053457600080fd5b506103ee610543366004613528565b6114a7565b34801561055457600080fd5b5061058a610563366004613368565b60106020526000908152604090208054600182015460028301546003909301549192909184565b6040805194855260208501939093529183015260608201526080016102d7565b3480156105b657600080fd5b5061061f6105c5366004613368565b600f60205260009081526040902080546001820154600283015460038401546004850154600586015460069096015473ffffffffffffffffffffffffffffffffffffffff95861696949590931693919260ff909116919087565b6040805173ffffffffffffffffffffffffffffffffffffffff98891681526020810197909752949096169385019390935260608401919091521515608083015260a082015260c081019190915260e0016102d7565b34801561068057600080fd5b506103ee600181565b34801561069557600080fd5b506103ee6106a4366004613368565b600d6020526000908152604090205481565b3480156106c257600080fd5b506103ee6106d13660046134f5565b611522565b3480156106e257600080fd5b506102f561169d565b6103ee6106f93660046133aa565b6116ac565b34801561070a57600080fd5b506102a9610719366004613543565b61185c565b34801561072a57600080fd5b506103ee61048381565b34801561074057600080fd5b506102a961074f366004613368565b611867565b34801561076057600080fd5b506103ee61076f3660046134f5565b6119c7565b34801561078057600080fd5b506103ee61078f366004613368565b600e6020526000908152604090205481565b3480156107ad57600080fd5b506102a96107bc36600461363e565b611b93565b3480156107cd57600080fd5b506102f56107dc366004613368565b611bb0565b3480156107ed57600080fd5b506103ee601481565b34801561080257600080fd5b506103227f000000000000000000000000000000000000000000000000000000000000000081565b34801561083657600080fd5b506102a96108453660046136e9565b611db7565b34801561085657600080fd5b506102cb610865366004613755565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260056020908152604080832093909416825291909152205460ff1690565b3480156108ac57600080fd5b506103ee6102d181565b3480156108c257600080fd5b506103ac6108d136600461377f565b7ff23a6e61000000000000000000000000000000000000000000000000000000009695505050505050565b6000878152600f60205260409020805473ffffffffffffffffffffffffffffffffffffffff16331461095a576040517f29f9fc8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b861561098f576004810180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00168715151790555b841561099d57600581018490555b82156109ab57600681018290555b80546004820154600583015460068401546040805160ff9094161515845260208401929092529082015273ffffffffffffffffffffffffffffffffffffffff9091169089907f8587d3b7f5e8e73d0f5be513ce84b6c7c9497e221295d831f57ba7ecc36589b59060600160405180910390a35050505050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f780e9d63000000000000000000000000000000000000000000000000000000001480610a7d5750610a7d82612113565b92915050565b606060008054610a92906137f7565b80601f0160208091040260200160405190810160405280929190818152602001828054610abe906137f7565b8015610b0b5780601f10610ae057610100808354040283529160200191610b0b565b820191906000526020600020905b815481529060010190602001808311610aee57829003601f168201915b5050505050905090565b6000610b20826121f6565b5060008281526004602052604090205473ffffffffffffffffffffffffffffffffffffffff16610a7d565b610b56828233612255565b5050565b600081815260106020908152604080832080548452600f909252909120600481015460ff16610bbd576040517f2ed602a6000000000000000000000000000000000000000000000000000000008152600481018490526024015b60405180910390fd5b610bc8858585612262565b5050505050565b610bd761234d565b600081815260106020908152604080832080548452600f90925282209091610bfe8461149c565b905073ffffffffffffffffffffffffffffffffffffffff81163314801590610c3d5750815473ffffffffffffffffffffffffffffffffffffffff163314155b15610c92576040517f5a4c507400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82166004820152336024820152604401610bb4565b600682015415610d035760038301541580610cbf575081600601548360030154610cbc9190613879565b42105b15610cfe5781600601546040517f2098e24d000000000000000000000000000000000000000000000000000000008152600401610bb491815260200190565b610d67565b81600501548360020154610d179190613879565b421015610d675781600501548360020154610d329190613879565b6040517f9dc1207c000000000000000000000000000000000000000000000000000000008152600401610bb491815260200190565b6102d1826001015403610d9a5782546000908152600d60205260408120805491610d908361388c565b9190505550610dc5565b600183015483546000908152600d602052604081208054909190610dbf9084906138c1565b90915550505b82546000908152600e60205260408120805491610de18361388c565b909155505060018301548354604080518781526020810184905273ffffffffffffffffffffffffffffffffffffffff8516917fffdaf13b1d96bfc2213355f353f84c19493e0681eb0df26f83d862acd266750a910160405180910390a36000858152601060205260408120818155600181018290556002810182905560030155610e6a85612390565b6001836001015403610ebf5760405173ffffffffffffffffffffffffffffffffffffffff83169082156108fc029083906000818181858888f19350505050158015610eb9573d6000803e3d6000fd5b50611058565b6014836001015403610ef6576002830154610ef19073ffffffffffffffffffffffffffffffffffffffff1683836123f1565b611058565b6102d1836001015403610f9c5760028301546040517f42842e0e00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff848116602483015260448201849052909116906342842e0e90606401600060405180830381600087803b158015610f7f57600080fd5b505af1158015610f93573d6000803e3d6000fd5b50505050611058565b61048383600101540361105857600283015460038401546040517ff242432a00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff858116602483015260448201929092526064810184905260a06084820152600060a482015291169063f242432a9060c401600060405180830381600087803b15801561103f57600080fd5b505af1158015611053573d6000803e3d6000fd5b505050505b505050506110666001600a55565b50565b6000611074836114a7565b82106110cb576040517fa57d13dc00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8416600482015260248101839052604401610bb4565b5073ffffffffffffffffffffffffffffffffffffffff919091166000908152600660209081526040808320938352929052205490565b6000828152600f60205260409020805473ffffffffffffffffffffffffffffffffffffffff16331461115f576040517f29f9fc8100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff831690811782556004820154600583015460068401546040805160ff9094161515845260208401929092529082015284907f8587d3b7f5e8e73d0f5be513ce84b6c7c9497e221295d831f57ba7ecc36589b5906060015b60405180910390a3505050565b61121783838360405180602001604052806000815250611b93565b505050565b600061122760085490565b8210611269576040517fa57d13dc0000000000000000000000000000000000000000000000000000000081526000600482015260248101839052604401610bb4565b6008828154811061127c5761127c6138d4565b90600052602060002001549050919050565b600061129861234d565b6000838152600f6020526040902060018101546102d1146112fd5760018101546040517f323b95bb0000000000000000000000000000000000000000000000000000000081526004810186905260248101919091526102d16044820152606401610bb4565b600c805490600061130d83613903565b9091555060408051608081018252868152602080820187815242838501908152600060608501818152878252601085528682209551865592516001860155905160028501559051600390930192909255878252600d905290812080549294509061137683613903565b90915550506000848152600e6020526040812080549161139583613903565b909155505060028101546040517f42842e0e0000000000000000000000000000000000000000000000000000000081523360048201523060248201526044810185905273ffffffffffffffffffffffffffffffffffffffff909116906342842e0e906064015b600060405180830381600087803b15801561141557600080fd5b505af1158015611429573d6000803e3d6000fd5b505050506114378583612472565b6040805183815260208101859052859173ffffffffffffffffffffffffffffffffffffffff8816917f17700ceb1658b18206f427c1578048e87504106b14ec69e9b4586d9a95174a32910160405180910390a3506114956001600a55565b9392505050565b6000610a7d826121f6565b600073ffffffffffffffffffffffffffffffffffffffff82166114f9576040517f89c62b6400000000000000000000000000000000000000000000000000000000815260006004820152602401610bb4565b5073ffffffffffffffffffffffffffffffffffffffff1660009081526003602052604090205490565b600061152c61234d565b6000838152600f60205260409020600181015460141461158f5760018101546040517f323b95bb00000000000000000000000000000000000000000000000000000000815260048101869052602481019190915260146044820152606401610bb4565b826000036115c9576040517fd23fa2a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600c80549060006115d983613903565b9091555060408051608081018252868152602080820187815242838501908152600060608501818152878252601085528682209551865592516001860155905160028501559051600390930192909255878252600d905290812080549294508592909190611648908490613879565b90915550506000848152600e6020526040812080549161166783613903565b909155505060028101546116939073ffffffffffffffffffffffffffffffffffffffff16333086612523565b6114378583612472565b606060018054610a92906137f7565b60006116b661234d565b6000828152600f602052604090206001808201541461171a576001818101546040517f323b95bb0000000000000000000000000000000000000000000000000000000081526004810186905260248101919091526044810191909152606401610bb4565b34600003611754576040517fd23fa2a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600c805490600061176483613903565b909155506040805160808101825285815234602080830182815242848601908152600060608601818152888252601085528782209651875592516001870155905160028601559051600390940193909355878352600d9052918120805493955091926117d1908490613879565b90915550506000838152600e602052604081208054916117f083613903565b91905055506117ff8483612472565b60408051838152346020820152849173ffffffffffffffffffffffffffffffffffffffff8716917f17700ceb1658b18206f427c1578048e87504106b14ec69e9b4586d9a95174a32910160405180910390a350610a7d6001600a55565b610b56338383612569565b61186f61234d565b600061187a8261149c565b600083815260106020908152604080832080548452600f9092529091209192509073ffffffffffffffffffffffffffffffffffffffff831633148015906118d85750805473ffffffffffffffffffffffffffffffffffffffff163314155b1561192d576040517f5a4c507400000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152336024820152604401610bb4565b806005015482600201546119419190613879565b42101561195c5780600501548260020154610d329190613879565b81600301546000036119ba5742600383015560405184815273ffffffffffffffffffffffffffffffffffffffff8416907fb88af44ff67f15b82bc60b5ecd6ac0f0c27da279a6c21b7d200174756ea5c5e49060200160405180910390a25b5050506110666001600a55565b60006119d161234d565b6000838152600f60205260409020600181015461048314611a365760018101546040517f323b95bb0000000000000000000000000000000000000000000000000000000081526004810186905260248101919091526104836044820152606401610bb4565b82600003611a70576040517fd23fa2a300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600c8054906000611a8083613903565b9091555060408051608081018252868152602080820187815242838501908152600060608501818152878252601085528682209551865592516001860155905160028501559051600390930192909255878252600d905290812080549294508592909190611aef908490613879565b90915550506000848152600e60205260408120805491611b0e83613903565b9091555050600281015460038201546040517ff242432a00000000000000000000000000000000000000000000000000000000815233600482015230602482015260448101919091526064810185905260a06084820152600060a482015273ffffffffffffffffffffffffffffffffffffffff9091169063f242432a9060c4016113fb565b611b9e848484610b5a565b611baa8484848461265e565b50505050565b6060611bbb826121f6565b5060008281526010602090815260408083208054808552600f90935281842091516024810187905260448101939093526001808201546064850152600280830154608486015260038084015460a4870152845473ffffffffffffffffffffffffffffffffffffffff90811660c48801529285015460e4870152908401548216610104860152830154610124850152600483015460ff161515610144850152600583015461016485015260068301546101848501529093919282917f000000000000000000000000000000000000000000000000000000000000000016906101a401604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f7b2f34ff0000000000000000000000000000000000000000000000000000000017905251611d1d919061393b565b600060405180830381855afa9150503d8060008114611d58576040519150601f19603f3d011682016040523d82523d6000602084013e611d5d565b606091505b509150915081611d99576040517f0e8d7e7400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80806020019051810190611dad9190613957565b9695505050505050565b60018703611e1e5773ffffffffffffffffffffffffffffffffffffffff8616151580611de257508415155b15611e19576040517fc52a9bd300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611f63565b60148703611e7c5773ffffffffffffffffffffffffffffffffffffffff86161580611de257508415611e19576040517fc52a9bd300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6102d18703611edb5773ffffffffffffffffffffffffffffffffffffffff86161580611de257508415611e19576040517fc52a9bd300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6104838703611f315773ffffffffffffffffffffffffffffffffffffffff8616611e19576040517fc52a9bd300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040517fa1e9dd9d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040805160e08101825273ffffffffffffffffffffffffffffffffffffffff838116825260208083018b81528a8316848601818152606086018c81528b15156080880190815260a088018c815260c089018c8152600b80546000908152600f8a528c90209a518b547fffffffffffffffffffffffff0000000000000000000000000000000000000000908116918c16919091178c55975160018c0155945160028b01805490981699169890981790955590516003880155516004870180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169115159190911790559151600586015592516006909401939093559154925188815290928a9290917f36b06296d9441695787e7cbfc0b9cfc5deeeabec4406a3a90d30a222103c2dc8910160405180910390a4600b546040805186151581526020810186905290810184905273ffffffffffffffffffffffffffffffffffffffff831691907f8587d3b7f5e8e73d0f5be513ce84b6c7c9497e221295d831f57ba7ecc36589b59060600160405180910390a3600b805490600061210583613903565b919050555050505050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f80ac58cd0000000000000000000000000000000000000000000000000000000014806121a657507fffffffff0000000000000000000000000000000000000000000000000000000082167f5b5e139f00000000000000000000000000000000000000000000000000000000145b80610a7d57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614610a7d565b60008181526002602052604081205473ffffffffffffffffffffffffffffffffffffffff1680610a7d576040517f7e27328900000000000000000000000000000000000000000000000000000000815260048101849052602401610bb4565b611217838383600161284e565b73ffffffffffffffffffffffffffffffffffffffff82166122b2576040517f64a0ae9200000000000000000000000000000000000000000000000000000000815260006004820152602401610bb4565b60006122bf838333612a19565b90508373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614611baa576040517f64283d7b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff80861660048301526024820184905282166044820152606401610bb4565b6002600a5403612389576040517f3ee5aeb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6002600a55565b600061239f6000836000612a19565b905073ffffffffffffffffffffffffffffffffffffffff8116610b56576040517f7e27328900000000000000000000000000000000000000000000000000000000815260048101839052602401610bb4565b60405173ffffffffffffffffffffffffffffffffffffffff83811660248301526044820183905261121791859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050612b3c565b73ffffffffffffffffffffffffffffffffffffffff82166124c2576040517f64a0ae9200000000000000000000000000000000000000000000000000000000815260006004820152602401610bb4565b60006124d083836000612a19565b905073ffffffffffffffffffffffffffffffffffffffff811615611217576040517f73c6ac6e00000000000000000000000000000000000000000000000000000000815260006004820152602401610bb4565b60405173ffffffffffffffffffffffffffffffffffffffff8481166024830152838116604483015260648201839052611baa9186918216906323b872dd9060840161242b565b73ffffffffffffffffffffffffffffffffffffffff82166125ce576040517f5b08ba1800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83166004820152602401610bb4565b73ffffffffffffffffffffffffffffffffffffffff83811660008181526005602090815260408083209487168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3191016111ef565b73ffffffffffffffffffffffffffffffffffffffff83163b15611baa576040517f150b7a0200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84169063150b7a02906126d39033908890879087906004016139ce565b6020604051808303816000875af192505050801561272c575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261272991810190613a1f565b60015b6127bb573d80801561275a576040519150601f19603f3d011682016040523d82523d6000602084013e61275f565b606091505b5080516000036127b3576040517f64a0ae9200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85166004820152602401610bb4565b805181602001fd5b7fffffffff0000000000000000000000000000000000000000000000000000000081167f150b7a020000000000000000000000000000000000000000000000000000000014610bc8576040517f64a0ae9200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85166004820152602401610bb4565b808061286f575073ffffffffffffffffffffffffffffffffffffffff821615155b156129c457600061287f846121f6565b905073ffffffffffffffffffffffffffffffffffffffff8316158015906128d257508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614155b8015612911575073ffffffffffffffffffffffffffffffffffffffff80821660009081526005602090815260408083209387168352929052205460ff16155b15612960576040517fa9fbf51f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152602401610bb4565b81156129c257838573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45b505b5050600090815260046020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b600080612a27858585612bd2565b905073ffffffffffffffffffffffffffffffffffffffff8116612a9157612a8c84600880546000838152600960205260408120829055600182018355919091527ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee30155565b612ace565b8473ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614612ace57612ace8185612d4f565b73ffffffffffffffffffffffffffffffffffffffff8516612af757612af284612dfa565b612b34565b8473ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614612b3457612b348585612ea9565b949350505050565b6000612b5e73ffffffffffffffffffffffffffffffffffffffff841683612f06565b90508051600014158015612b83575080806020019051810190612b819190613a3c565b155b15611217576040517f5274afe700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84166004820152602401610bb4565b60008281526002602052604081205473ffffffffffffffffffffffffffffffffffffffff90811690831615612c0c57612c0c818486612f14565b73ffffffffffffffffffffffffffffffffffffffff811615612c8257612c3660008560008061284e565b73ffffffffffffffffffffffffffffffffffffffff8116600090815260036020526040902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190555b73ffffffffffffffffffffffffffffffffffffffff851615612ccb5773ffffffffffffffffffffffffffffffffffffffff85166000908152600360205260409020805460010190555b60008481526002602052604080822080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff89811691821790925591518793918516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4949350505050565b6000612d5a836114a7565b600083815260076020526040902054909150808214612dba5773ffffffffffffffffffffffffffffffffffffffff841660009081526006602090815260408083208584528252808320548484528184208190558352600790915290208190555b50600091825260076020908152604080842084905573ffffffffffffffffffffffffffffffffffffffff9094168352600681528383209183525290812055565b600854600090612e0c906001906138c1565b60008381526009602052604081205460088054939450909284908110612e3457612e346138d4565b906000526020600020015490508060088381548110612e5557612e556138d4565b6000918252602080832090910192909255828152600990915260408082208490558582528120556008805480612e8d57612e8d613a59565b6001900381819060005260206000200160009055905550505050565b60006001612eb6846114a7565b612ec091906138c1565b73ffffffffffffffffffffffffffffffffffffffff9093166000908152600660209081526040808320868452825280832085905593825260079052919091209190915550565b606061149583836000612fc4565b612f1f83838361307d565b6112175773ffffffffffffffffffffffffffffffffffffffff8316612f73576040517f7e27328900000000000000000000000000000000000000000000000000000000815260048101829052602401610bb4565b6040517f177e802f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8316600482015260248101829052604401610bb4565b606081471015613002576040517fcd786059000000000000000000000000000000000000000000000000000000008152306004820152602401610bb4565b6000808573ffffffffffffffffffffffffffffffffffffffff16848660405161302b919061393b565b60006040518083038185875af1925050503d8060008114613068576040519150601f19603f3d011682016040523d82523d6000602084013e61306d565b606091505b5091509150611dad868383613141565b600073ffffffffffffffffffffffffffffffffffffffff831615801590612b3457508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16148061310b575073ffffffffffffffffffffffffffffffffffffffff80851660009081526005602090815260408083209387168352929052205460ff165b80612b3457505060009081526004602052604090205473ffffffffffffffffffffffffffffffffffffffff908116911614919050565b60608261315657613151826131d0565b611495565b815115801561317a575073ffffffffffffffffffffffffffffffffffffffff84163b155b156131c9576040517f9996b31500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85166004820152602401610bb4565b5080611495565b8051156131e05780518082602001fd5b6040517f1425ea4200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b801515811461106657600080fd5b600080600080600080600060e0888a03121561323b57600080fd5b87359650602088013561324d81613212565b9550604088013561325d81613212565b9450606088013561326d81613212565b93506080880135925060a088013561328481613212565b96999598509396929591949193505060c09091013590565b7fffffffff000000000000000000000000000000000000000000000000000000008116811461106657600080fd5b6000602082840312156132dc57600080fd5b81356114958161329c565b60005b838110156133025781810151838201526020016132ea565b50506000910152565b600081518084526133238160208601602086016132e7565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000611495602083018461330b565b60006020828403121561337a57600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff811681146133a557600080fd5b919050565b600080604083850312156133bd57600080fd5b6133c683613381565b946020939093013593505050565b60008083601f8401126133e657600080fd5b50813567ffffffffffffffff8111156133fe57600080fd5b60208301915083602082850101111561341657600080fd5b9250929050565b60008060008060006080868803121561343557600080fd5b61343e86613381565b945061344c60208701613381565b935060408601359250606086013567ffffffffffffffff81111561346f57600080fd5b61347b888289016133d4565b969995985093965092949392505050565b6000806000606084860312156134a157600080fd5b6134aa84613381565b92506134b860208501613381565b929592945050506040919091013590565b600080604083850312156134dc57600080fd5b823591506134ec60208401613381565b90509250929050565b60008060006060848603121561350a57600080fd5b61351384613381565b95602085013595506040909401359392505050565b60006020828403121561353a57600080fd5b61149582613381565b6000806040838503121561355657600080fd5b61355f83613381565b9150602083013561356f81613212565b809150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156135f0576135f061357a565b604052919050565b600067ffffffffffffffff8211156136125761361261357a565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b6000806000806080858703121561365457600080fd5b61365d85613381565b935061366b60208601613381565b925060408501359150606085013567ffffffffffffffff81111561368e57600080fd5b8501601f8101871361369f57600080fd5b80356136b26136ad826135f8565b6135a9565b8181528860208385010111156136c757600080fd5b8160208401602083013760006020838301015280935050505092959194509250565b600080600080600080600060e0888a03121561370457600080fd5b8735965061371460208901613381565b955060408801359450606088013561372b81613212565b93506080880135925060a0880135915061374760c08901613381565b905092959891949750929550565b6000806040838503121561376857600080fd5b61377183613381565b91506134ec60208401613381565b60008060008060008060a0878903121561379857600080fd5b6137a187613381565b95506137af60208801613381565b94506040870135935060608701359250608087013567ffffffffffffffff8111156137d957600080fd5b6137e589828a016133d4565b979a9699509497509295939492505050565b600181811c9082168061380b57607f821691505b602082108103613844577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b80820180821115610a7d57610a7d61384a565b60008161389b5761389b61384a565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b81810381811115610a7d57610a7d61384a565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036139345761393461384a565b5060010190565b6000825161394d8184602087016132e7565b9190910192915050565b60006020828403121561396957600080fd5b815167ffffffffffffffff81111561398057600080fd5b8201601f8101841361399157600080fd5b805161399f6136ad826135f8565b8181528560208385010111156139b457600080fd5b6139c58260208301602086016132e7565b95945050505050565b73ffffffffffffffffffffffffffffffffffffffff8516815273ffffffffffffffffffffffffffffffffffffffff84166020820152826040820152608060608201526000611dad608083018461330b565b600060208284031215613a3157600080fd5b81516114958161329c565b600060208284031215613a4e57600080fd5b815161149581613212565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fdfea2646970667358221220eb228e544f9e7fbaea56482008cecd0f11e14a7e7b53a91c366f5d37e48613f664736f6c634300081c0033",
}

// StakerABI is the input ABI used to generate the binding from.
// Deprecated: Use StakerMetaData.ABI instead.
var StakerABI = StakerMetaData.ABI

// StakerBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use StakerMetaData.Bin instead.
var StakerBin = StakerMetaData.Bin

// DeployStaker deploys a new Ethereum contract, binding an instance of Staker to it.
func DeployStaker(auth *bind.TransactOpts, backend bind.ContractBackend, positionMetadata common.Address) (common.Address, *types.Transaction, *Staker, error) {
	parsed, err := StakerMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(StakerBin), backend, positionMetadata)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Staker{StakerCaller: StakerCaller{contract: contract}, StakerTransactor: StakerTransactor{contract: contract}, StakerFilterer: StakerFilterer{contract: contract}}, nil
}

// Staker is an auto generated Go binding around an Ethereum contract.
type Staker struct {
	StakerCaller     // Read-only binding to the contract
	StakerTransactor // Write-only binding to the contract
	StakerFilterer   // Log filterer for contract events
}

// StakerCaller is an auto generated read-only Go binding around an Ethereum contract.
type StakerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StakerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StakerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StakerSession struct {
	Contract     *Staker           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StakerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StakerCallerSession struct {
	Contract *StakerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// StakerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StakerTransactorSession struct {
	Contract     *StakerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StakerRaw is an auto generated low-level Go binding around an Ethereum contract.
type StakerRaw struct {
	Contract *Staker // Generic contract binding to access the raw methods on
}

// StakerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StakerCallerRaw struct {
	Contract *StakerCaller // Generic read-only contract binding to access the raw methods on
}

// StakerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StakerTransactorRaw struct {
	Contract *StakerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStaker creates a new instance of Staker, bound to a specific deployed contract.
func NewStaker(address common.Address, backend bind.ContractBackend) (*Staker, error) {
	contract, err := bindStaker(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Staker{StakerCaller: StakerCaller{contract: contract}, StakerTransactor: StakerTransactor{contract: contract}, StakerFilterer: StakerFilterer{contract: contract}}, nil
}

// NewStakerCaller creates a new read-only instance of Staker, bound to a specific deployed contract.
func NewStakerCaller(address common.Address, caller bind.ContractCaller) (*StakerCaller, error) {
	contract, err := bindStaker(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StakerCaller{contract: contract}, nil
}

// NewStakerTransactor creates a new write-only instance of Staker, bound to a specific deployed contract.
func NewStakerTransactor(address common.Address, transactor bind.ContractTransactor) (*StakerTransactor, error) {
	contract, err := bindStaker(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StakerTransactor{contract: contract}, nil
}

// NewStakerFilterer creates a new log filterer instance of Staker, bound to a specific deployed contract.
func NewStakerFilterer(address common.Address, filterer bind.ContractFilterer) (*StakerFilterer, error) {
	contract, err := bindStaker(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StakerFilterer{contract: contract}, nil
}

// bindStaker binds a generic wrapper to an already deployed contract.
func bindStaker(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := StakerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staker *StakerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Staker.Contract.StakerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staker *StakerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staker.Contract.StakerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staker *StakerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staker.Contract.StakerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staker *StakerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Staker.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staker *StakerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staker.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staker *StakerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staker.Contract.contract.Transact(opts, method, params...)
}

// CurrentAmountInPool is a free data retrieval call binding the contract method 0x81c822e6.
//
// Solidity: function CurrentAmountInPool(uint256 ) view returns(uint256)
func (_Staker *StakerCaller) CurrentAmountInPool(opts *bind.CallOpts, arg0 *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "CurrentAmountInPool", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CurrentAmountInPool is a free data retrieval call binding the contract method 0x81c822e6.
//
// Solidity: function CurrentAmountInPool(uint256 ) view returns(uint256)
func (_Staker *StakerSession) CurrentAmountInPool(arg0 *big.Int) (*big.Int, error) {
	return _Staker.Contract.CurrentAmountInPool(&_Staker.CallOpts, arg0)
}

// CurrentAmountInPool is a free data retrieval call binding the contract method 0x81c822e6.
//
// Solidity: function CurrentAmountInPool(uint256 ) view returns(uint256)
func (_Staker *StakerCallerSession) CurrentAmountInPool(arg0 *big.Int) (*big.Int, error) {
	return _Staker.Contract.CurrentAmountInPool(&_Staker.CallOpts, arg0)
}

// CurrentPositionsInPool is a free data retrieval call binding the contract method 0xb29087da.
//
// Solidity: function CurrentPositionsInPool(uint256 ) view returns(uint256)
func (_Staker *StakerCaller) CurrentPositionsInPool(opts *bind.CallOpts, arg0 *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "CurrentPositionsInPool", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CurrentPositionsInPool is a free data retrieval call binding the contract method 0xb29087da.
//
// Solidity: function CurrentPositionsInPool(uint256 ) view returns(uint256)
func (_Staker *StakerSession) CurrentPositionsInPool(arg0 *big.Int) (*big.Int, error) {
	return _Staker.Contract.CurrentPositionsInPool(&_Staker.CallOpts, arg0)
}

// CurrentPositionsInPool is a free data retrieval call binding the contract method 0xb29087da.
//
// Solidity: function CurrentPositionsInPool(uint256 ) view returns(uint256)
func (_Staker *StakerCallerSession) CurrentPositionsInPool(arg0 *big.Int) (*big.Int, error) {
	return _Staker.Contract.CurrentPositionsInPool(&_Staker.CallOpts, arg0)
}

// ERC1155TOKENTYPE is a free data retrieval call binding the contract method 0xabd4ce78.
//
// Solidity: function ERC1155_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerCaller) ERC1155TOKENTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "ERC1155_TOKEN_TYPE")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ERC1155TOKENTYPE is a free data retrieval call binding the contract method 0xabd4ce78.
//
// Solidity: function ERC1155_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerSession) ERC1155TOKENTYPE() (*big.Int, error) {
	return _Staker.Contract.ERC1155TOKENTYPE(&_Staker.CallOpts)
}

// ERC1155TOKENTYPE is a free data retrieval call binding the contract method 0xabd4ce78.
//
// Solidity: function ERC1155_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerCallerSession) ERC1155TOKENTYPE() (*big.Int, error) {
	return _Staker.Contract.ERC1155TOKENTYPE(&_Staker.CallOpts)
}

// ERC20TOKENTYPE is a free data retrieval call binding the contract method 0xd2ba4409.
//
// Solidity: function ERC20_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerCaller) ERC20TOKENTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "ERC20_TOKEN_TYPE")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ERC20TOKENTYPE is a free data retrieval call binding the contract method 0xd2ba4409.
//
// Solidity: function ERC20_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerSession) ERC20TOKENTYPE() (*big.Int, error) {
	return _Staker.Contract.ERC20TOKENTYPE(&_Staker.CallOpts)
}

// ERC20TOKENTYPE is a free data retrieval call binding the contract method 0xd2ba4409.
//
// Solidity: function ERC20_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerCallerSession) ERC20TOKENTYPE() (*big.Int, error) {
	return _Staker.Contract.ERC20TOKENTYPE(&_Staker.CallOpts)
}

// ERC721TOKENTYPE is a free data retrieval call binding the contract method 0xf09e76a1.
//
// Solidity: function ERC721_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerCaller) ERC721TOKENTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "ERC721_TOKEN_TYPE")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ERC721TOKENTYPE is a free data retrieval call binding the contract method 0xf09e76a1.
//
// Solidity: function ERC721_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerSession) ERC721TOKENTYPE() (*big.Int, error) {
	return _Staker.Contract.ERC721TOKENTYPE(&_Staker.CallOpts)
}

// ERC721TOKENTYPE is a free data retrieval call binding the contract method 0xf09e76a1.
//
// Solidity: function ERC721_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerCallerSession) ERC721TOKENTYPE() (*big.Int, error) {
	return _Staker.Contract.ERC721TOKENTYPE(&_Staker.CallOpts)
}

// NATIVETOKENTYPE is a free data retrieval call binding the contract method 0x77bd2e78.
//
// Solidity: function NATIVE_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerCaller) NATIVETOKENTYPE(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "NATIVE_TOKEN_TYPE")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// NATIVETOKENTYPE is a free data retrieval call binding the contract method 0x77bd2e78.
//
// Solidity: function NATIVE_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerSession) NATIVETOKENTYPE() (*big.Int, error) {
	return _Staker.Contract.NATIVETOKENTYPE(&_Staker.CallOpts)
}

// NATIVETOKENTYPE is a free data retrieval call binding the contract method 0x77bd2e78.
//
// Solidity: function NATIVE_TOKEN_TYPE() view returns(uint256)
func (_Staker *StakerCallerSession) NATIVETOKENTYPE() (*big.Int, error) {
	return _Staker.Contract.NATIVETOKENTYPE(&_Staker.CallOpts)
}

// Pools is a free data retrieval call binding the contract method 0x73dfccca.
//
// Solidity: function Pools(uint256 ) view returns(address administrator, uint256 tokenType, address tokenAddress, uint256 tokenID, bool transferable, uint256 lockupSeconds, uint256 cooldownSeconds)
func (_Staker *StakerCaller) Pools(opts *bind.CallOpts, arg0 *big.Int) (struct {
	Administrator   common.Address
	TokenType       *big.Int
	TokenAddress    common.Address
	TokenID         *big.Int
	Transferable    bool
	LockupSeconds   *big.Int
	CooldownSeconds *big.Int
}, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "Pools", arg0)

	outstruct := new(struct {
		Administrator   common.Address
		TokenType       *big.Int
		TokenAddress    common.Address
		TokenID         *big.Int
		Transferable    bool
		LockupSeconds   *big.Int
		CooldownSeconds *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Administrator = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.TokenType = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.TokenAddress = *abi.ConvertType(out[2], new(common.Address)).(*common.Address)
	outstruct.TokenID = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.Transferable = *abi.ConvertType(out[4], new(bool)).(*bool)
	outstruct.LockupSeconds = *abi.ConvertType(out[5], new(*big.Int)).(**big.Int)
	outstruct.CooldownSeconds = *abi.ConvertType(out[6], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// Pools is a free data retrieval call binding the contract method 0x73dfccca.
//
// Solidity: function Pools(uint256 ) view returns(address administrator, uint256 tokenType, address tokenAddress, uint256 tokenID, bool transferable, uint256 lockupSeconds, uint256 cooldownSeconds)
func (_Staker *StakerSession) Pools(arg0 *big.Int) (struct {
	Administrator   common.Address
	TokenType       *big.Int
	TokenAddress    common.Address
	TokenID         *big.Int
	Transferable    bool
	LockupSeconds   *big.Int
	CooldownSeconds *big.Int
}, error) {
	return _Staker.Contract.Pools(&_Staker.CallOpts, arg0)
}

// Pools is a free data retrieval call binding the contract method 0x73dfccca.
//
// Solidity: function Pools(uint256 ) view returns(address administrator, uint256 tokenType, address tokenAddress, uint256 tokenID, bool transferable, uint256 lockupSeconds, uint256 cooldownSeconds)
func (_Staker *StakerCallerSession) Pools(arg0 *big.Int) (struct {
	Administrator   common.Address
	TokenType       *big.Int
	TokenAddress    common.Address
	TokenID         *big.Int
	Transferable    bool
	LockupSeconds   *big.Int
	CooldownSeconds *big.Int
}, error) {
	return _Staker.Contract.Pools(&_Staker.CallOpts, arg0)
}

// Positions is a free data retrieval call binding the contract method 0x73caf0f7.
//
// Solidity: function Positions(uint256 ) view returns(uint256 poolID, uint256 amountOrTokenID, uint256 stakeTimestamp, uint256 unstakeInitiatedAt)
func (_Staker *StakerCaller) Positions(opts *bind.CallOpts, arg0 *big.Int) (struct {
	PoolID             *big.Int
	AmountOrTokenID    *big.Int
	StakeTimestamp     *big.Int
	UnstakeInitiatedAt *big.Int
}, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "Positions", arg0)

	outstruct := new(struct {
		PoolID             *big.Int
		AmountOrTokenID    *big.Int
		StakeTimestamp     *big.Int
		UnstakeInitiatedAt *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.PoolID = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.AmountOrTokenID = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.StakeTimestamp = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.UnstakeInitiatedAt = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// Positions is a free data retrieval call binding the contract method 0x73caf0f7.
//
// Solidity: function Positions(uint256 ) view returns(uint256 poolID, uint256 amountOrTokenID, uint256 stakeTimestamp, uint256 unstakeInitiatedAt)
func (_Staker *StakerSession) Positions(arg0 *big.Int) (struct {
	PoolID             *big.Int
	AmountOrTokenID    *big.Int
	StakeTimestamp     *big.Int
	UnstakeInitiatedAt *big.Int
}, error) {
	return _Staker.Contract.Positions(&_Staker.CallOpts, arg0)
}

// Positions is a free data retrieval call binding the contract method 0x73caf0f7.
//
// Solidity: function Positions(uint256 ) view returns(uint256 poolID, uint256 amountOrTokenID, uint256 stakeTimestamp, uint256 unstakeInitiatedAt)
func (_Staker *StakerCallerSession) Positions(arg0 *big.Int) (struct {
	PoolID             *big.Int
	AmountOrTokenID    *big.Int
	StakeTimestamp     *big.Int
	UnstakeInitiatedAt *big.Int
}, error) {
	return _Staker.Contract.Positions(&_Staker.CallOpts, arg0)
}

// TotalPools is a free data retrieval call binding the contract method 0x424b9311.
//
// Solidity: function TotalPools() view returns(uint256)
func (_Staker *StakerCaller) TotalPools(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "TotalPools")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalPools is a free data retrieval call binding the contract method 0x424b9311.
//
// Solidity: function TotalPools() view returns(uint256)
func (_Staker *StakerSession) TotalPools() (*big.Int, error) {
	return _Staker.Contract.TotalPools(&_Staker.CallOpts)
}

// TotalPools is a free data retrieval call binding the contract method 0x424b9311.
//
// Solidity: function TotalPools() view returns(uint256)
func (_Staker *StakerCallerSession) TotalPools() (*big.Int, error) {
	return _Staker.Contract.TotalPools(&_Staker.CallOpts)
}

// TotalPositions is a free data retrieval call binding the contract method 0x3ab0f1c1.
//
// Solidity: function TotalPositions() view returns(uint256)
func (_Staker *StakerCaller) TotalPositions(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "TotalPositions")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalPositions is a free data retrieval call binding the contract method 0x3ab0f1c1.
//
// Solidity: function TotalPositions() view returns(uint256)
func (_Staker *StakerSession) TotalPositions() (*big.Int, error) {
	return _Staker.Contract.TotalPositions(&_Staker.CallOpts)
}

// TotalPositions is a free data retrieval call binding the contract method 0x3ab0f1c1.
//
// Solidity: function TotalPositions() view returns(uint256)
func (_Staker *StakerCallerSession) TotalPositions() (*big.Int, error) {
	return _Staker.Contract.TotalPositions(&_Staker.CallOpts)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_Staker *StakerCaller) BalanceOf(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "balanceOf", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_Staker *StakerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _Staker.Contract.BalanceOf(&_Staker.CallOpts, owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address owner) view returns(uint256)
func (_Staker *StakerCallerSession) BalanceOf(owner common.Address) (*big.Int, error) {
	return _Staker.Contract.BalanceOf(&_Staker.CallOpts, owner)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_Staker *StakerCaller) GetApproved(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "getApproved", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_Staker *StakerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _Staker.Contract.GetApproved(&_Staker.CallOpts, tokenId)
}

// GetApproved is a free data retrieval call binding the contract method 0x081812fc.
//
// Solidity: function getApproved(uint256 tokenId) view returns(address)
func (_Staker *StakerCallerSession) GetApproved(tokenId *big.Int) (common.Address, error) {
	return _Staker.Contract.GetApproved(&_Staker.CallOpts, tokenId)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_Staker *StakerCaller) IsApprovedForAll(opts *bind.CallOpts, owner common.Address, operator common.Address) (bool, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "isApprovedForAll", owner, operator)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_Staker *StakerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _Staker.Contract.IsApprovedForAll(&_Staker.CallOpts, owner, operator)
}

// IsApprovedForAll is a free data retrieval call binding the contract method 0xe985e9c5.
//
// Solidity: function isApprovedForAll(address owner, address operator) view returns(bool)
func (_Staker *StakerCallerSession) IsApprovedForAll(owner common.Address, operator common.Address) (bool, error) {
	return _Staker.Contract.IsApprovedForAll(&_Staker.CallOpts, owner, operator)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Staker *StakerCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Staker *StakerSession) Name() (string, error) {
	return _Staker.Contract.Name(&_Staker.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Staker *StakerCallerSession) Name() (string, error) {
	return _Staker.Contract.Name(&_Staker.CallOpts)
}

// OnERC1155Received is a free data retrieval call binding the contract method 0xf23a6e61.
//
// Solidity: function onERC1155Received(address , address , uint256 , uint256 , bytes ) pure returns(bytes4)
func (_Staker *StakerCaller) OnERC1155Received(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 *big.Int, arg4 []byte) ([4]byte, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "onERC1155Received", arg0, arg1, arg2, arg3, arg4)

	if err != nil {
		return *new([4]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([4]byte)).(*[4]byte)

	return out0, err

}

// OnERC1155Received is a free data retrieval call binding the contract method 0xf23a6e61.
//
// Solidity: function onERC1155Received(address , address , uint256 , uint256 , bytes ) pure returns(bytes4)
func (_Staker *StakerSession) OnERC1155Received(arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 *big.Int, arg4 []byte) ([4]byte, error) {
	return _Staker.Contract.OnERC1155Received(&_Staker.CallOpts, arg0, arg1, arg2, arg3, arg4)
}

// OnERC1155Received is a free data retrieval call binding the contract method 0xf23a6e61.
//
// Solidity: function onERC1155Received(address , address , uint256 , uint256 , bytes ) pure returns(bytes4)
func (_Staker *StakerCallerSession) OnERC1155Received(arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 *big.Int, arg4 []byte) ([4]byte, error) {
	return _Staker.Contract.OnERC1155Received(&_Staker.CallOpts, arg0, arg1, arg2, arg3, arg4)
}

// OnERC721Received is a free data retrieval call binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address , address , uint256 , bytes ) pure returns(bytes4)
func (_Staker *StakerCaller) OnERC721Received(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "onERC721Received", arg0, arg1, arg2, arg3)

	if err != nil {
		return *new([4]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([4]byte)).(*[4]byte)

	return out0, err

}

// OnERC721Received is a free data retrieval call binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address , address , uint256 , bytes ) pure returns(bytes4)
func (_Staker *StakerSession) OnERC721Received(arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	return _Staker.Contract.OnERC721Received(&_Staker.CallOpts, arg0, arg1, arg2, arg3)
}

// OnERC721Received is a free data retrieval call binding the contract method 0x150b7a02.
//
// Solidity: function onERC721Received(address , address , uint256 , bytes ) pure returns(bytes4)
func (_Staker *StakerCallerSession) OnERC721Received(arg0 common.Address, arg1 common.Address, arg2 *big.Int, arg3 []byte) ([4]byte, error) {
	return _Staker.Contract.OnERC721Received(&_Staker.CallOpts, arg0, arg1, arg2, arg3)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_Staker *StakerCaller) OwnerOf(opts *bind.CallOpts, tokenId *big.Int) (common.Address, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "ownerOf", tokenId)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_Staker *StakerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _Staker.Contract.OwnerOf(&_Staker.CallOpts, tokenId)
}

// OwnerOf is a free data retrieval call binding the contract method 0x6352211e.
//
// Solidity: function ownerOf(uint256 tokenId) view returns(address)
func (_Staker *StakerCallerSession) OwnerOf(tokenId *big.Int) (common.Address, error) {
	return _Staker.Contract.OwnerOf(&_Staker.CallOpts, tokenId)
}

// PositionMetadataAddress is a free data retrieval call binding the contract method 0xd693595d.
//
// Solidity: function positionMetadataAddress() view returns(address)
func (_Staker *StakerCaller) PositionMetadataAddress(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "positionMetadataAddress")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PositionMetadataAddress is a free data retrieval call binding the contract method 0xd693595d.
//
// Solidity: function positionMetadataAddress() view returns(address)
func (_Staker *StakerSession) PositionMetadataAddress() (common.Address, error) {
	return _Staker.Contract.PositionMetadataAddress(&_Staker.CallOpts)
}

// PositionMetadataAddress is a free data retrieval call binding the contract method 0xd693595d.
//
// Solidity: function positionMetadataAddress() view returns(address)
func (_Staker *StakerCallerSession) PositionMetadataAddress() (common.Address, error) {
	return _Staker.Contract.PositionMetadataAddress(&_Staker.CallOpts)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_Staker *StakerCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_Staker *StakerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _Staker.Contract.SupportsInterface(&_Staker.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_Staker *StakerCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _Staker.Contract.SupportsInterface(&_Staker.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_Staker *StakerCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_Staker *StakerSession) Symbol() (string, error) {
	return _Staker.Contract.Symbol(&_Staker.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_Staker *StakerCallerSession) Symbol() (string, error) {
	return _Staker.Contract.Symbol(&_Staker.CallOpts)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_Staker *StakerCaller) TokenByIndex(opts *bind.CallOpts, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "tokenByIndex", index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_Staker *StakerSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _Staker.Contract.TokenByIndex(&_Staker.CallOpts, index)
}

// TokenByIndex is a free data retrieval call binding the contract method 0x4f6ccce7.
//
// Solidity: function tokenByIndex(uint256 index) view returns(uint256)
func (_Staker *StakerCallerSession) TokenByIndex(index *big.Int) (*big.Int, error) {
	return _Staker.Contract.TokenByIndex(&_Staker.CallOpts, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_Staker *StakerCaller) TokenOfOwnerByIndex(opts *bind.CallOpts, owner common.Address, index *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "tokenOfOwnerByIndex", owner, index)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_Staker *StakerSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _Staker.Contract.TokenOfOwnerByIndex(&_Staker.CallOpts, owner, index)
}

// TokenOfOwnerByIndex is a free data retrieval call binding the contract method 0x2f745c59.
//
// Solidity: function tokenOfOwnerByIndex(address owner, uint256 index) view returns(uint256)
func (_Staker *StakerCallerSession) TokenOfOwnerByIndex(owner common.Address, index *big.Int) (*big.Int, error) {
	return _Staker.Contract.TokenOfOwnerByIndex(&_Staker.CallOpts, owner, index)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_Staker *StakerCaller) TokenURI(opts *bind.CallOpts, tokenId *big.Int) (string, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "tokenURI", tokenId)

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_Staker *StakerSession) TokenURI(tokenId *big.Int) (string, error) {
	return _Staker.Contract.TokenURI(&_Staker.CallOpts, tokenId)
}

// TokenURI is a free data retrieval call binding the contract method 0xc87b56dd.
//
// Solidity: function tokenURI(uint256 tokenId) view returns(string)
func (_Staker *StakerCallerSession) TokenURI(tokenId *big.Int) (string, error) {
	return _Staker.Contract.TokenURI(&_Staker.CallOpts, tokenId)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_Staker *StakerCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Staker.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_Staker *StakerSession) TotalSupply() (*big.Int, error) {
	return _Staker.Contract.TotalSupply(&_Staker.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_Staker *StakerCallerSession) TotalSupply() (*big.Int, error) {
	return _Staker.Contract.TotalSupply(&_Staker.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_Staker *StakerTransactor) Approve(opts *bind.TransactOpts, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "approve", to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_Staker *StakerSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.Approve(&_Staker.TransactOpts, to, tokenId)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address to, uint256 tokenId) returns()
func (_Staker *StakerTransactorSession) Approve(to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.Approve(&_Staker.TransactOpts, to, tokenId)
}

// CreatePool is a paid mutator transaction binding the contract method 0xdf44bf76.
//
// Solidity: function createPool(uint256 tokenType, address tokenAddress, uint256 tokenID, bool transferable, uint256 lockupSeconds, uint256 cooldownSeconds, address administrator) returns()
func (_Staker *StakerTransactor) CreatePool(opts *bind.TransactOpts, tokenType *big.Int, tokenAddress common.Address, tokenID *big.Int, transferable bool, lockupSeconds *big.Int, cooldownSeconds *big.Int, administrator common.Address) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "createPool", tokenType, tokenAddress, tokenID, transferable, lockupSeconds, cooldownSeconds, administrator)
}

// CreatePool is a paid mutator transaction binding the contract method 0xdf44bf76.
//
// Solidity: function createPool(uint256 tokenType, address tokenAddress, uint256 tokenID, bool transferable, uint256 lockupSeconds, uint256 cooldownSeconds, address administrator) returns()
func (_Staker *StakerSession) CreatePool(tokenType *big.Int, tokenAddress common.Address, tokenID *big.Int, transferable bool, lockupSeconds *big.Int, cooldownSeconds *big.Int, administrator common.Address) (*types.Transaction, error) {
	return _Staker.Contract.CreatePool(&_Staker.TransactOpts, tokenType, tokenAddress, tokenID, transferable, lockupSeconds, cooldownSeconds, administrator)
}

// CreatePool is a paid mutator transaction binding the contract method 0xdf44bf76.
//
// Solidity: function createPool(uint256 tokenType, address tokenAddress, uint256 tokenID, bool transferable, uint256 lockupSeconds, uint256 cooldownSeconds, address administrator) returns()
func (_Staker *StakerTransactorSession) CreatePool(tokenType *big.Int, tokenAddress common.Address, tokenID *big.Int, transferable bool, lockupSeconds *big.Int, cooldownSeconds *big.Int, administrator common.Address) (*types.Transaction, error) {
	return _Staker.Contract.CreatePool(&_Staker.TransactOpts, tokenType, tokenAddress, tokenID, transferable, lockupSeconds, cooldownSeconds, administrator)
}

// InitiateUnstake is a paid mutator transaction binding the contract method 0xae5ac921.
//
// Solidity: function initiateUnstake(uint256 positionTokenID) returns()
func (_Staker *StakerTransactor) InitiateUnstake(opts *bind.TransactOpts, positionTokenID *big.Int) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "initiateUnstake", positionTokenID)
}

// InitiateUnstake is a paid mutator transaction binding the contract method 0xae5ac921.
//
// Solidity: function initiateUnstake(uint256 positionTokenID) returns()
func (_Staker *StakerSession) InitiateUnstake(positionTokenID *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.InitiateUnstake(&_Staker.TransactOpts, positionTokenID)
}

// InitiateUnstake is a paid mutator transaction binding the contract method 0xae5ac921.
//
// Solidity: function initiateUnstake(uint256 positionTokenID) returns()
func (_Staker *StakerTransactorSession) InitiateUnstake(positionTokenID *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.InitiateUnstake(&_Staker.TransactOpts, positionTokenID)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_Staker *StakerTransactor) SafeTransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "safeTransferFrom", from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_Staker *StakerSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.SafeTransferFrom(&_Staker.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom is a paid mutator transaction binding the contract method 0x42842e0e.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId) returns()
func (_Staker *StakerTransactorSession) SafeTransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.SafeTransferFrom(&_Staker.TransactOpts, from, to, tokenId)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_Staker *StakerTransactor) SafeTransferFrom0(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "safeTransferFrom0", from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_Staker *StakerSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _Staker.Contract.SafeTransferFrom0(&_Staker.TransactOpts, from, to, tokenId, data)
}

// SafeTransferFrom0 is a paid mutator transaction binding the contract method 0xb88d4fde.
//
// Solidity: function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) returns()
func (_Staker *StakerTransactorSession) SafeTransferFrom0(from common.Address, to common.Address, tokenId *big.Int, data []byte) (*types.Transaction, error) {
	return _Staker.Contract.SafeTransferFrom0(&_Staker.TransactOpts, from, to, tokenId, data)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_Staker *StakerTransactor) SetApprovalForAll(opts *bind.TransactOpts, operator common.Address, approved bool) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "setApprovalForAll", operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_Staker *StakerSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _Staker.Contract.SetApprovalForAll(&_Staker.TransactOpts, operator, approved)
}

// SetApprovalForAll is a paid mutator transaction binding the contract method 0xa22cb465.
//
// Solidity: function setApprovalForAll(address operator, bool approved) returns()
func (_Staker *StakerTransactorSession) SetApprovalForAll(operator common.Address, approved bool) (*types.Transaction, error) {
	return _Staker.Contract.SetApprovalForAll(&_Staker.TransactOpts, operator, approved)
}

// StakeERC1155 is a paid mutator transaction binding the contract method 0xb0fe4a7e.
//
// Solidity: function stakeERC1155(address positionHolder, uint256 poolID, uint256 amount) returns(uint256 positionTokenID)
func (_Staker *StakerTransactor) StakeERC1155(opts *bind.TransactOpts, positionHolder common.Address, poolID *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "stakeERC1155", positionHolder, poolID, amount)
}

// StakeERC1155 is a paid mutator transaction binding the contract method 0xb0fe4a7e.
//
// Solidity: function stakeERC1155(address positionHolder, uint256 poolID, uint256 amount) returns(uint256 positionTokenID)
func (_Staker *StakerSession) StakeERC1155(positionHolder common.Address, poolID *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.StakeERC1155(&_Staker.TransactOpts, positionHolder, poolID, amount)
}

// StakeERC1155 is a paid mutator transaction binding the contract method 0xb0fe4a7e.
//
// Solidity: function stakeERC1155(address positionHolder, uint256 poolID, uint256 amount) returns(uint256 positionTokenID)
func (_Staker *StakerTransactorSession) StakeERC1155(positionHolder common.Address, poolID *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.StakeERC1155(&_Staker.TransactOpts, positionHolder, poolID, amount)
}

// StakeERC20 is a paid mutator transaction binding the contract method 0x8d4a9e85.
//
// Solidity: function stakeERC20(address positionHolder, uint256 poolID, uint256 amount) returns(uint256 positionTokenID)
func (_Staker *StakerTransactor) StakeERC20(opts *bind.TransactOpts, positionHolder common.Address, poolID *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "stakeERC20", positionHolder, poolID, amount)
}

// StakeERC20 is a paid mutator transaction binding the contract method 0x8d4a9e85.
//
// Solidity: function stakeERC20(address positionHolder, uint256 poolID, uint256 amount) returns(uint256 positionTokenID)
func (_Staker *StakerSession) StakeERC20(positionHolder common.Address, poolID *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.StakeERC20(&_Staker.TransactOpts, positionHolder, poolID, amount)
}

// StakeERC20 is a paid mutator transaction binding the contract method 0x8d4a9e85.
//
// Solidity: function stakeERC20(address positionHolder, uint256 poolID, uint256 amount) returns(uint256 positionTokenID)
func (_Staker *StakerTransactorSession) StakeERC20(positionHolder common.Address, poolID *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.StakeERC20(&_Staker.TransactOpts, positionHolder, poolID, amount)
}

// StakeERC721 is a paid mutator transaction binding the contract method 0x621519c0.
//
// Solidity: function stakeERC721(address positionHolder, uint256 poolID, uint256 tokenID) returns(uint256 positionTokenID)
func (_Staker *StakerTransactor) StakeERC721(opts *bind.TransactOpts, positionHolder common.Address, poolID *big.Int, tokenID *big.Int) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "stakeERC721", positionHolder, poolID, tokenID)
}

// StakeERC721 is a paid mutator transaction binding the contract method 0x621519c0.
//
// Solidity: function stakeERC721(address positionHolder, uint256 poolID, uint256 tokenID) returns(uint256 positionTokenID)
func (_Staker *StakerSession) StakeERC721(positionHolder common.Address, poolID *big.Int, tokenID *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.StakeERC721(&_Staker.TransactOpts, positionHolder, poolID, tokenID)
}

// StakeERC721 is a paid mutator transaction binding the contract method 0x621519c0.
//
// Solidity: function stakeERC721(address positionHolder, uint256 poolID, uint256 tokenID) returns(uint256 positionTokenID)
func (_Staker *StakerTransactorSession) StakeERC721(positionHolder common.Address, poolID *big.Int, tokenID *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.StakeERC721(&_Staker.TransactOpts, positionHolder, poolID, tokenID)
}

// StakeNative is a paid mutator transaction binding the contract method 0xa1ed8fef.
//
// Solidity: function stakeNative(address positionHolder, uint256 poolID) payable returns(uint256 positionTokenID)
func (_Staker *StakerTransactor) StakeNative(opts *bind.TransactOpts, positionHolder common.Address, poolID *big.Int) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "stakeNative", positionHolder, poolID)
}

// StakeNative is a paid mutator transaction binding the contract method 0xa1ed8fef.
//
// Solidity: function stakeNative(address positionHolder, uint256 poolID) payable returns(uint256 positionTokenID)
func (_Staker *StakerSession) StakeNative(positionHolder common.Address, poolID *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.StakeNative(&_Staker.TransactOpts, positionHolder, poolID)
}

// StakeNative is a paid mutator transaction binding the contract method 0xa1ed8fef.
//
// Solidity: function stakeNative(address positionHolder, uint256 poolID) payable returns(uint256 positionTokenID)
func (_Staker *StakerTransactorSession) StakeNative(positionHolder common.Address, poolID *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.StakeNative(&_Staker.TransactOpts, positionHolder, poolID)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_Staker *StakerTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "transferFrom", from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_Staker *StakerSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.TransferFrom(&_Staker.TransactOpts, from, to, tokenId)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 tokenId) returns()
func (_Staker *StakerTransactorSession) TransferFrom(from common.Address, to common.Address, tokenId *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.TransferFrom(&_Staker.TransactOpts, from, to, tokenId)
}

// TransferPoolAdministration is a paid mutator transaction binding the contract method 0x3db26319.
//
// Solidity: function transferPoolAdministration(uint256 poolID, address newAdministrator) returns()
func (_Staker *StakerTransactor) TransferPoolAdministration(opts *bind.TransactOpts, poolID *big.Int, newAdministrator common.Address) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "transferPoolAdministration", poolID, newAdministrator)
}

// TransferPoolAdministration is a paid mutator transaction binding the contract method 0x3db26319.
//
// Solidity: function transferPoolAdministration(uint256 poolID, address newAdministrator) returns()
func (_Staker *StakerSession) TransferPoolAdministration(poolID *big.Int, newAdministrator common.Address) (*types.Transaction, error) {
	return _Staker.Contract.TransferPoolAdministration(&_Staker.TransactOpts, poolID, newAdministrator)
}

// TransferPoolAdministration is a paid mutator transaction binding the contract method 0x3db26319.
//
// Solidity: function transferPoolAdministration(uint256 poolID, address newAdministrator) returns()
func (_Staker *StakerTransactorSession) TransferPoolAdministration(poolID *big.Int, newAdministrator common.Address) (*types.Transaction, error) {
	return _Staker.Contract.TransferPoolAdministration(&_Staker.TransactOpts, poolID, newAdministrator)
}

// Unstake is a paid mutator transaction binding the contract method 0x2e17de78.
//
// Solidity: function unstake(uint256 positionTokenID) returns()
func (_Staker *StakerTransactor) Unstake(opts *bind.TransactOpts, positionTokenID *big.Int) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "unstake", positionTokenID)
}

// Unstake is a paid mutator transaction binding the contract method 0x2e17de78.
//
// Solidity: function unstake(uint256 positionTokenID) returns()
func (_Staker *StakerSession) Unstake(positionTokenID *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.Unstake(&_Staker.TransactOpts, positionTokenID)
}

// Unstake is a paid mutator transaction binding the contract method 0x2e17de78.
//
// Solidity: function unstake(uint256 positionTokenID) returns()
func (_Staker *StakerTransactorSession) Unstake(positionTokenID *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.Unstake(&_Staker.TransactOpts, positionTokenID)
}

// UpdatePoolConfiguration is a paid mutator transaction binding the contract method 0x007d0cec.
//
// Solidity: function updatePoolConfiguration(uint256 poolID, bool changeTransferability, bool transferable, bool changeLockup, uint256 lockupSeconds, bool changeCooldown, uint256 cooldownSeconds) returns()
func (_Staker *StakerTransactor) UpdatePoolConfiguration(opts *bind.TransactOpts, poolID *big.Int, changeTransferability bool, transferable bool, changeLockup bool, lockupSeconds *big.Int, changeCooldown bool, cooldownSeconds *big.Int) (*types.Transaction, error) {
	return _Staker.contract.Transact(opts, "updatePoolConfiguration", poolID, changeTransferability, transferable, changeLockup, lockupSeconds, changeCooldown, cooldownSeconds)
}

// UpdatePoolConfiguration is a paid mutator transaction binding the contract method 0x007d0cec.
//
// Solidity: function updatePoolConfiguration(uint256 poolID, bool changeTransferability, bool transferable, bool changeLockup, uint256 lockupSeconds, bool changeCooldown, uint256 cooldownSeconds) returns()
func (_Staker *StakerSession) UpdatePoolConfiguration(poolID *big.Int, changeTransferability bool, transferable bool, changeLockup bool, lockupSeconds *big.Int, changeCooldown bool, cooldownSeconds *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.UpdatePoolConfiguration(&_Staker.TransactOpts, poolID, changeTransferability, transferable, changeLockup, lockupSeconds, changeCooldown, cooldownSeconds)
}

// UpdatePoolConfiguration is a paid mutator transaction binding the contract method 0x007d0cec.
//
// Solidity: function updatePoolConfiguration(uint256 poolID, bool changeTransferability, bool transferable, bool changeLockup, uint256 lockupSeconds, bool changeCooldown, uint256 cooldownSeconds) returns()
func (_Staker *StakerTransactorSession) UpdatePoolConfiguration(poolID *big.Int, changeTransferability bool, transferable bool, changeLockup bool, lockupSeconds *big.Int, changeCooldown bool, cooldownSeconds *big.Int) (*types.Transaction, error) {
	return _Staker.Contract.UpdatePoolConfiguration(&_Staker.TransactOpts, poolID, changeTransferability, transferable, changeLockup, lockupSeconds, changeCooldown, cooldownSeconds)
}

// StakerApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the Staker contract.
type StakerApprovalIterator struct {
	Event *StakerApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakerApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakerApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakerApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakerApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakerApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakerApproval represents a Approval event raised by the Staker contract.
type StakerApproval struct {
	Owner    common.Address
	Approved common.Address
	TokenId  *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_Staker *StakerFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, approved []common.Address, tokenId []*big.Int) (*StakerApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _Staker.contract.FilterLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &StakerApprovalIterator{contract: _Staker.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_Staker *StakerFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *StakerApproval, owner []common.Address, approved []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var approvedRule []interface{}
	for _, approvedItem := range approved {
		approvedRule = append(approvedRule, approvedItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _Staker.contract.WatchLogs(opts, "Approval", ownerRule, approvedRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakerApproval)
				if err := _Staker.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
func (_Staker *StakerFilterer) ParseApproval(log types.Log) (*StakerApproval, error) {
	event := new(StakerApproval)
	if err := _Staker.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// StakerApprovalForAllIterator is returned from FilterApprovalForAll and is used to iterate over the raw logs and unpacked data for ApprovalForAll events raised by the Staker contract.
type StakerApprovalForAllIterator struct {
	Event *StakerApprovalForAll // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakerApprovalForAllIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakerApprovalForAll)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakerApprovalForAll)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakerApprovalForAllIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakerApprovalForAllIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakerApprovalForAll represents a ApprovalForAll event raised by the Staker contract.
type StakerApprovalForAll struct {
	Owner    common.Address
	Operator common.Address
	Approved bool
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterApprovalForAll is a free log retrieval operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_Staker *StakerFilterer) FilterApprovalForAll(opts *bind.FilterOpts, owner []common.Address, operator []common.Address) (*StakerApprovalForAllIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _Staker.contract.FilterLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return &StakerApprovalForAllIterator{contract: _Staker.contract, event: "ApprovalForAll", logs: logs, sub: sub}, nil
}

// WatchApprovalForAll is a free log subscription operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_Staker *StakerFilterer) WatchApprovalForAll(opts *bind.WatchOpts, sink chan<- *StakerApprovalForAll, owner []common.Address, operator []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var operatorRule []interface{}
	for _, operatorItem := range operator {
		operatorRule = append(operatorRule, operatorItem)
	}

	logs, sub, err := _Staker.contract.WatchLogs(opts, "ApprovalForAll", ownerRule, operatorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakerApprovalForAll)
				if err := _Staker.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApprovalForAll is a log parse operation binding the contract event 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31.
//
// Solidity: event ApprovalForAll(address indexed owner, address indexed operator, bool approved)
func (_Staker *StakerFilterer) ParseApprovalForAll(log types.Log) (*StakerApprovalForAll, error) {
	event := new(StakerApprovalForAll)
	if err := _Staker.contract.UnpackLog(event, "ApprovalForAll", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// StakerStakedIterator is returned from FilterStaked and is used to iterate over the raw logs and unpacked data for Staked events raised by the Staker contract.
type StakerStakedIterator struct {
	Event *StakerStaked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakerStakedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakerStaked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakerStaked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakerStakedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakerStakedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakerStaked represents a Staked event raised by the Staker contract.
type StakerStaked struct {
	PositionTokenID *big.Int
	Owner           common.Address
	PoolID          *big.Int
	AmountOrTokenID *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterStaked is a free log retrieval operation binding the contract event 0x17700ceb1658b18206f427c1578048e87504106b14ec69e9b4586d9a95174a32.
//
// Solidity: event Staked(uint256 positionTokenID, address indexed owner, uint256 indexed poolID, uint256 amountOrTokenID)
func (_Staker *StakerFilterer) FilterStaked(opts *bind.FilterOpts, owner []common.Address, poolID []*big.Int) (*StakerStakedIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var poolIDRule []interface{}
	for _, poolIDItem := range poolID {
		poolIDRule = append(poolIDRule, poolIDItem)
	}

	logs, sub, err := _Staker.contract.FilterLogs(opts, "Staked", ownerRule, poolIDRule)
	if err != nil {
		return nil, err
	}
	return &StakerStakedIterator{contract: _Staker.contract, event: "Staked", logs: logs, sub: sub}, nil
}

// WatchStaked is a free log subscription operation binding the contract event 0x17700ceb1658b18206f427c1578048e87504106b14ec69e9b4586d9a95174a32.
//
// Solidity: event Staked(uint256 positionTokenID, address indexed owner, uint256 indexed poolID, uint256 amountOrTokenID)
func (_Staker *StakerFilterer) WatchStaked(opts *bind.WatchOpts, sink chan<- *StakerStaked, owner []common.Address, poolID []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var poolIDRule []interface{}
	for _, poolIDItem := range poolID {
		poolIDRule = append(poolIDRule, poolIDItem)
	}

	logs, sub, err := _Staker.contract.WatchLogs(opts, "Staked", ownerRule, poolIDRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakerStaked)
				if err := _Staker.contract.UnpackLog(event, "Staked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStaked is a log parse operation binding the contract event 0x17700ceb1658b18206f427c1578048e87504106b14ec69e9b4586d9a95174a32.
//
// Solidity: event Staked(uint256 positionTokenID, address indexed owner, uint256 indexed poolID, uint256 amountOrTokenID)
func (_Staker *StakerFilterer) ParseStaked(log types.Log) (*StakerStaked, error) {
	event := new(StakerStaked)
	if err := _Staker.contract.UnpackLog(event, "Staked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// StakerStakingPoolConfiguredIterator is returned from FilterStakingPoolConfigured and is used to iterate over the raw logs and unpacked data for StakingPoolConfigured events raised by the Staker contract.
type StakerStakingPoolConfiguredIterator struct {
	Event *StakerStakingPoolConfigured // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakerStakingPoolConfiguredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakerStakingPoolConfigured)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakerStakingPoolConfigured)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakerStakingPoolConfiguredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakerStakingPoolConfiguredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakerStakingPoolConfigured represents a StakingPoolConfigured event raised by the Staker contract.
type StakerStakingPoolConfigured struct {
	PoolID          *big.Int
	Administrator   common.Address
	Transferable    bool
	LockupSeconds   *big.Int
	CooldownSeconds *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterStakingPoolConfigured is a free log retrieval operation binding the contract event 0x8587d3b7f5e8e73d0f5be513ce84b6c7c9497e221295d831f57ba7ecc36589b5.
//
// Solidity: event StakingPoolConfigured(uint256 indexed poolID, address indexed administrator, bool transferable, uint256 lockupSeconds, uint256 cooldownSeconds)
func (_Staker *StakerFilterer) FilterStakingPoolConfigured(opts *bind.FilterOpts, poolID []*big.Int, administrator []common.Address) (*StakerStakingPoolConfiguredIterator, error) {

	var poolIDRule []interface{}
	for _, poolIDItem := range poolID {
		poolIDRule = append(poolIDRule, poolIDItem)
	}
	var administratorRule []interface{}
	for _, administratorItem := range administrator {
		administratorRule = append(administratorRule, administratorItem)
	}

	logs, sub, err := _Staker.contract.FilterLogs(opts, "StakingPoolConfigured", poolIDRule, administratorRule)
	if err != nil {
		return nil, err
	}
	return &StakerStakingPoolConfiguredIterator{contract: _Staker.contract, event: "StakingPoolConfigured", logs: logs, sub: sub}, nil
}

// WatchStakingPoolConfigured is a free log subscription operation binding the contract event 0x8587d3b7f5e8e73d0f5be513ce84b6c7c9497e221295d831f57ba7ecc36589b5.
//
// Solidity: event StakingPoolConfigured(uint256 indexed poolID, address indexed administrator, bool transferable, uint256 lockupSeconds, uint256 cooldownSeconds)
func (_Staker *StakerFilterer) WatchStakingPoolConfigured(opts *bind.WatchOpts, sink chan<- *StakerStakingPoolConfigured, poolID []*big.Int, administrator []common.Address) (event.Subscription, error) {

	var poolIDRule []interface{}
	for _, poolIDItem := range poolID {
		poolIDRule = append(poolIDRule, poolIDItem)
	}
	var administratorRule []interface{}
	for _, administratorItem := range administrator {
		administratorRule = append(administratorRule, administratorItem)
	}

	logs, sub, err := _Staker.contract.WatchLogs(opts, "StakingPoolConfigured", poolIDRule, administratorRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakerStakingPoolConfigured)
				if err := _Staker.contract.UnpackLog(event, "StakingPoolConfigured", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStakingPoolConfigured is a log parse operation binding the contract event 0x8587d3b7f5e8e73d0f5be513ce84b6c7c9497e221295d831f57ba7ecc36589b5.
//
// Solidity: event StakingPoolConfigured(uint256 indexed poolID, address indexed administrator, bool transferable, uint256 lockupSeconds, uint256 cooldownSeconds)
func (_Staker *StakerFilterer) ParseStakingPoolConfigured(log types.Log) (*StakerStakingPoolConfigured, error) {
	event := new(StakerStakingPoolConfigured)
	if err := _Staker.contract.UnpackLog(event, "StakingPoolConfigured", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// StakerStakingPoolCreatedIterator is returned from FilterStakingPoolCreated and is used to iterate over the raw logs and unpacked data for StakingPoolCreated events raised by the Staker contract.
type StakerStakingPoolCreatedIterator struct {
	Event *StakerStakingPoolCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakerStakingPoolCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakerStakingPoolCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakerStakingPoolCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakerStakingPoolCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakerStakingPoolCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakerStakingPoolCreated represents a StakingPoolCreated event raised by the Staker contract.
type StakerStakingPoolCreated struct {
	PoolID       *big.Int
	TokenType    *big.Int
	TokenAddress common.Address
	TokenID      *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterStakingPoolCreated is a free log retrieval operation binding the contract event 0x36b06296d9441695787e7cbfc0b9cfc5deeeabec4406a3a90d30a222103c2dc8.
//
// Solidity: event StakingPoolCreated(uint256 indexed poolID, uint256 indexed tokenType, address indexed tokenAddress, uint256 tokenID)
func (_Staker *StakerFilterer) FilterStakingPoolCreated(opts *bind.FilterOpts, poolID []*big.Int, tokenType []*big.Int, tokenAddress []common.Address) (*StakerStakingPoolCreatedIterator, error) {

	var poolIDRule []interface{}
	for _, poolIDItem := range poolID {
		poolIDRule = append(poolIDRule, poolIDItem)
	}
	var tokenTypeRule []interface{}
	for _, tokenTypeItem := range tokenType {
		tokenTypeRule = append(tokenTypeRule, tokenTypeItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _Staker.contract.FilterLogs(opts, "StakingPoolCreated", poolIDRule, tokenTypeRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return &StakerStakingPoolCreatedIterator{contract: _Staker.contract, event: "StakingPoolCreated", logs: logs, sub: sub}, nil
}

// WatchStakingPoolCreated is a free log subscription operation binding the contract event 0x36b06296d9441695787e7cbfc0b9cfc5deeeabec4406a3a90d30a222103c2dc8.
//
// Solidity: event StakingPoolCreated(uint256 indexed poolID, uint256 indexed tokenType, address indexed tokenAddress, uint256 tokenID)
func (_Staker *StakerFilterer) WatchStakingPoolCreated(opts *bind.WatchOpts, sink chan<- *StakerStakingPoolCreated, poolID []*big.Int, tokenType []*big.Int, tokenAddress []common.Address) (event.Subscription, error) {

	var poolIDRule []interface{}
	for _, poolIDItem := range poolID {
		poolIDRule = append(poolIDRule, poolIDItem)
	}
	var tokenTypeRule []interface{}
	for _, tokenTypeItem := range tokenType {
		tokenTypeRule = append(tokenTypeRule, tokenTypeItem)
	}
	var tokenAddressRule []interface{}
	for _, tokenAddressItem := range tokenAddress {
		tokenAddressRule = append(tokenAddressRule, tokenAddressItem)
	}

	logs, sub, err := _Staker.contract.WatchLogs(opts, "StakingPoolCreated", poolIDRule, tokenTypeRule, tokenAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakerStakingPoolCreated)
				if err := _Staker.contract.UnpackLog(event, "StakingPoolCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseStakingPoolCreated is a log parse operation binding the contract event 0x36b06296d9441695787e7cbfc0b9cfc5deeeabec4406a3a90d30a222103c2dc8.
//
// Solidity: event StakingPoolCreated(uint256 indexed poolID, uint256 indexed tokenType, address indexed tokenAddress, uint256 tokenID)
func (_Staker *StakerFilterer) ParseStakingPoolCreated(log types.Log) (*StakerStakingPoolCreated, error) {
	event := new(StakerStakingPoolCreated)
	if err := _Staker.contract.UnpackLog(event, "StakingPoolCreated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// StakerTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the Staker contract.
type StakerTransferIterator struct {
	Event *StakerTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakerTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakerTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakerTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakerTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakerTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakerTransfer represents a Transfer event raised by the Staker contract.
type StakerTransfer struct {
	From    common.Address
	To      common.Address
	TokenId *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_Staker *StakerFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address, tokenId []*big.Int) (*StakerTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _Staker.contract.FilterLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return &StakerTransferIterator{contract: _Staker.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_Staker *StakerFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *StakerTransfer, from []common.Address, to []common.Address, tokenId []*big.Int) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var tokenIdRule []interface{}
	for _, tokenIdItem := range tokenId {
		tokenIdRule = append(tokenIdRule, tokenIdItem)
	}

	logs, sub, err := _Staker.contract.WatchLogs(opts, "Transfer", fromRule, toRule, tokenIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakerTransfer)
				if err := _Staker.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
func (_Staker *StakerFilterer) ParseTransfer(log types.Log) (*StakerTransfer, error) {
	event := new(StakerTransfer)
	if err := _Staker.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// StakerUnstakeInitiatedIterator is returned from FilterUnstakeInitiated and is used to iterate over the raw logs and unpacked data for UnstakeInitiated events raised by the Staker contract.
type StakerUnstakeInitiatedIterator struct {
	Event *StakerUnstakeInitiated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakerUnstakeInitiatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakerUnstakeInitiated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakerUnstakeInitiated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakerUnstakeInitiatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakerUnstakeInitiatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakerUnstakeInitiated represents a UnstakeInitiated event raised by the Staker contract.
type StakerUnstakeInitiated struct {
	PositionTokenID *big.Int
	Owner           common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterUnstakeInitiated is a free log retrieval operation binding the contract event 0xb88af44ff67f15b82bc60b5ecd6ac0f0c27da279a6c21b7d200174756ea5c5e4.
//
// Solidity: event UnstakeInitiated(uint256 positionTokenID, address indexed owner)
func (_Staker *StakerFilterer) FilterUnstakeInitiated(opts *bind.FilterOpts, owner []common.Address) (*StakerUnstakeInitiatedIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Staker.contract.FilterLogs(opts, "UnstakeInitiated", ownerRule)
	if err != nil {
		return nil, err
	}
	return &StakerUnstakeInitiatedIterator{contract: _Staker.contract, event: "UnstakeInitiated", logs: logs, sub: sub}, nil
}

// WatchUnstakeInitiated is a free log subscription operation binding the contract event 0xb88af44ff67f15b82bc60b5ecd6ac0f0c27da279a6c21b7d200174756ea5c5e4.
//
// Solidity: event UnstakeInitiated(uint256 positionTokenID, address indexed owner)
func (_Staker *StakerFilterer) WatchUnstakeInitiated(opts *bind.WatchOpts, sink chan<- *StakerUnstakeInitiated, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Staker.contract.WatchLogs(opts, "UnstakeInitiated", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakerUnstakeInitiated)
				if err := _Staker.contract.UnpackLog(event, "UnstakeInitiated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnstakeInitiated is a log parse operation binding the contract event 0xb88af44ff67f15b82bc60b5ecd6ac0f0c27da279a6c21b7d200174756ea5c5e4.
//
// Solidity: event UnstakeInitiated(uint256 positionTokenID, address indexed owner)
func (_Staker *StakerFilterer) ParseUnstakeInitiated(log types.Log) (*StakerUnstakeInitiated, error) {
	event := new(StakerUnstakeInitiated)
	if err := _Staker.contract.UnpackLog(event, "UnstakeInitiated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// StakerUnstakedIterator is returned from FilterUnstaked and is used to iterate over the raw logs and unpacked data for Unstaked events raised by the Staker contract.
type StakerUnstakedIterator struct {
	Event *StakerUnstaked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakerUnstakedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakerUnstaked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakerUnstaked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakerUnstakedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakerUnstakedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakerUnstaked represents a Unstaked event raised by the Staker contract.
type StakerUnstaked struct {
	PositionTokenID *big.Int
	Owner           common.Address
	PoolID          *big.Int
	AmountOrTokenID *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterUnstaked is a free log retrieval operation binding the contract event 0xffdaf13b1d96bfc2213355f353f84c19493e0681eb0df26f83d862acd266750a.
//
// Solidity: event Unstaked(uint256 positionTokenID, address indexed owner, uint256 indexed poolID, uint256 amountOrTokenID)
func (_Staker *StakerFilterer) FilterUnstaked(opts *bind.FilterOpts, owner []common.Address, poolID []*big.Int) (*StakerUnstakedIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var poolIDRule []interface{}
	for _, poolIDItem := range poolID {
		poolIDRule = append(poolIDRule, poolIDItem)
	}

	logs, sub, err := _Staker.contract.FilterLogs(opts, "Unstaked", ownerRule, poolIDRule)
	if err != nil {
		return nil, err
	}
	return &StakerUnstakedIterator{contract: _Staker.contract, event: "Unstaked", logs: logs, sub: sub}, nil
}

// WatchUnstaked is a free log subscription operation binding the contract event 0xffdaf13b1d96bfc2213355f353f84c19493e0681eb0df26f83d862acd266750a.
//
// Solidity: event Unstaked(uint256 positionTokenID, address indexed owner, uint256 indexed poolID, uint256 amountOrTokenID)
func (_Staker *StakerFilterer) WatchUnstaked(opts *bind.WatchOpts, sink chan<- *StakerUnstaked, owner []common.Address, poolID []*big.Int) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var poolIDRule []interface{}
	for _, poolIDItem := range poolID {
		poolIDRule = append(poolIDRule, poolIDItem)
	}

	logs, sub, err := _Staker.contract.WatchLogs(opts, "Unstaked", ownerRule, poolIDRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakerUnstaked)
				if err := _Staker.contract.UnpackLog(event, "Unstaked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnstaked is a log parse operation binding the contract event 0xffdaf13b1d96bfc2213355f353f84c19493e0681eb0df26f83d862acd266750a.
//
// Solidity: event Unstaked(uint256 positionTokenID, address indexed owner, uint256 indexed poolID, uint256 amountOrTokenID)
func (_Staker *StakerFilterer) ParseUnstaked(log types.Log) (*StakerUnstaked, error) {
	event := new(StakerUnstaked)
	if err := _Staker.contract.UnpackLog(event, "Unstaked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

func CreateStakerDeploymentCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var safeAddress, safeApi, safeCreateCall, safeSaltRaw, safeNonceRaw string
	var safeOperationType uint8
	var salt [32]byte
	var predictAddress bool
	var safeNonce *big.Int
	var calldata bool

	var positionMetadata common.Address
	var positionMetadataRaw string

	cmd := &cobra.Command{
		Use:   "deploy",
		Short: "Deploy a new Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {

			if !calldata {
				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if safeCreateCall == "" {
					fmt.Println("--safe-create-call not specified, using default (0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4)")
					safeCreateCall = "0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4"
				}
				if !common.IsHexAddress(safeCreateCall) {
					return fmt.Errorf("--safe-create-call is not a valid Ethereum address")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeSaltRaw == "" {
					fmt.Println("--safe-salt not specified, generating random salt")
					_, err := rand.Read(salt[:])
					if err != nil {
						return fmt.Errorf("failed to generate random salt: %v", err)
					}
					// prompt user to accept random salt
					fmt.Println("Generated salt:", common.Bytes2Hex(salt[:]))
					fmt.Println("Please check the salt and confirm (y/n)")
					var confirm string
					fmt.Scanln(&confirm)
					if confirm != "y" && confirm != "Y" && confirm != "\n" && confirm != "" {
						return fmt.Errorf("salt not accepted, please specify a valid salt")
					}
				} else {
					copy(salt[:], safeSaltRaw)
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if positionMetadataRaw == "" {
				return fmt.Errorf("--position-metadata argument not specified")
			} else if !common.IsHexAddress(positionMetadataRaw) {
				return fmt.Errorf("--position-metadata argument is not a valid Ethereum address")
			}
			positionMetadata = common.HexToAddress(positionMetadataRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			// Generate deploy bytecode with constructor arguments
			deployCalldata, err := generateStakerDeployBytecode(
				positionMetadata,
			)
			if err != nil {
				return fmt.Errorf("failed to generate deploy bytecode: %v", err)
			}

			if calldata {
				deployCalldataHex := hex.EncodeToString(deployCalldata)
				cmd.Println(deployCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			if safeAddress != "" {
				// Create Safe proposal for deployment
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				if predictAddress {
					fmt.Println("Predicting deployment address...")
					from := common.HexToAddress(safeAddress)
					if safeOperationType == 0 {
						from = common.HexToAddress(safeCreateCall)
					}
					deploymentAddress, err := PredictDeploymentAddressSafe(from, salt, deployCalldata)
					if err != nil {
						return fmt.Errorf("failed to predict deployment address: %v", err)
					}
					fmt.Println("Predicted deployment address:", deploymentAddress.Hex())
					return nil
				} else {
					fmt.Println("Creating Safe proposal...")
					err = DeployWithSafe(client, key, common.HexToAddress(safeAddress), common.HexToAddress(safeCreateCall), value, safeApi, deployCalldata, SafeOperationType(safeOperationType), salt, safeNonce)
					if err != nil {
						return fmt.Errorf("failed to create Safe proposal: %v", err)
					}
				}

				return nil
			}

			address, deploymentTransaction, _, deploymentErr := DeployStaker(
				transactionOpts,
				client,
				positionMetadata,
			)
			if deploymentErr != nil {
				return deploymentErr
			}

			cmd.Printf("Transaction hash: %s\nContract address: %s\n", deploymentTransaction.Hash().Hex(), address.Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					Data: deploymentTransaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := deploymentTransaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().StringVar(&safeCreateCall, "safe-create-call", "", "Address of the CreateCall contract (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 1, "Safe operation type: 0 (Call) or 1 (DelegateCall) - default is 1")
	cmd.Flags().StringVar(&safeSaltRaw, "safe-salt", "", "Salt to use for the Safe transaction")
	cmd.Flags().BoolVar(&predictAddress, "safe-predict-address", false, "Predict the deployment address (only works for Safe transactions)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&positionMetadataRaw, "position-metadata", "", "position-metadata argument (common.Address)")

	return cmd
}

func generateStakerDeployBytecode(
	positionMetadata common.Address,
) ([]byte, error) {
	abiPacked, err := StakerMetaData.GetAbi()
	if err != nil {
		return nil, fmt.Errorf("failed to get ABI: %v", err)
	}

	constructorArguments, err := abiPacked.Pack("",
		positionMetadata,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to pack constructor arguments: %v", err)
	}

	deployBytecode := append(common.FromHex(StakerMetaData.Bin), constructorArguments...)
	return deployBytecode, nil
}

func CreateBalanceOfCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var owner common.Address
	var ownerRaw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "balance-of",
		Short: "Call the BalanceOf view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if ownerRaw == "" {
				return fmt.Errorf("--owner argument not specified")
			} else if !common.IsHexAddress(ownerRaw) {
				return fmt.Errorf("--owner argument is not a valid Ethereum address")
			}
			owner = common.HexToAddress(ownerRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.BalanceOf(
				owner,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&ownerRaw, "owner", "", "owner argument (common.Address)")

	return cmd
}
func CreateCurrentAmountInPoolCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 *big.Int
	var arg0Raw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "current-amount-in-pool",
		Short: "Call the CurrentAmountInPool view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if arg0Raw == "" {
				return fmt.Errorf("--arg-0 argument not specified")
			}
			arg0 = new(big.Int)
			arg0.SetString(arg0Raw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.CurrentAmountInPool(
				arg0,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument")

	return cmd
}
func CreateCurrentPositionsInPoolCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 *big.Int
	var arg0Raw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "current-positions-in-pool",
		Short: "Call the CurrentPositionsInPool view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if arg0Raw == "" {
				return fmt.Errorf("--arg-0 argument not specified")
			}
			arg0 = new(big.Int)
			arg0.SetString(arg0Raw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.CurrentPositionsInPool(
				arg0,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument")

	return cmd
}
func CreateErc1155TokentypeCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "erc-1155-tokentype",
		Short: "Call the ERC1155TOKENTYPE view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.ERC1155TOKENTYPE()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateErc20TokentypeCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "erc-20-tokentype",
		Short: "Call the ERC20TOKENTYPE view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.ERC20TOKENTYPE()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateErc721TokentypeCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "erc-721-tokentype",
		Short: "Call the ERC721TOKENTYPE view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.ERC721TOKENTYPE()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateGetApprovedCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var tokenId *big.Int
	var tokenIdRaw string

	var capture0 common.Address

	cmd := &cobra.Command{
		Use:   "get-approved",
		Short: "Call the GetApproved view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if tokenIdRaw == "" {
				return fmt.Errorf("--token-id argument not specified")
			}
			tokenId = new(big.Int)
			tokenId.SetString(tokenIdRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.GetApproved(
				tokenId,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.Hex())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&tokenIdRaw, "token-id", "", "token-id argument")

	return cmd
}
func CreateIsApprovedForAllCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var owner common.Address
	var ownerRaw string
	var operator common.Address
	var operatorRaw string

	var capture0 bool

	cmd := &cobra.Command{
		Use:   "is-approved-for-all",
		Short: "Call the IsApprovedForAll view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if ownerRaw == "" {
				return fmt.Errorf("--owner argument not specified")
			} else if !common.IsHexAddress(ownerRaw) {
				return fmt.Errorf("--owner argument is not a valid Ethereum address")
			}
			owner = common.HexToAddress(ownerRaw)

			if operatorRaw == "" {
				return fmt.Errorf("--operator argument not specified")
			} else if !common.IsHexAddress(operatorRaw) {
				return fmt.Errorf("--operator argument is not a valid Ethereum address")
			}
			operator = common.HexToAddress(operatorRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.IsApprovedForAll(
				owner,
				operator,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %t\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&ownerRaw, "owner", "", "owner argument (common.Address)")
	cmd.Flags().StringVar(&operatorRaw, "operator", "", "operator argument (common.Address)")

	return cmd
}
func CreateNativetokentypeCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "nativetokentype",
		Short: "Call the NATIVETOKENTYPE view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.NATIVETOKENTYPE()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateNameCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 string

	cmd := &cobra.Command{
		Use:   "name",
		Short: "Call the Name view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Name()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateOnErc1155ReceivedCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 common.Address
	var arg0Raw string
	var arg1 common.Address
	var arg1Raw string
	var arg2 *big.Int
	var arg2Raw string
	var arg3 *big.Int
	var arg3Raw string
	var arg4 []byte
	var arg4Raw string

	var capture0 [4]byte

	cmd := &cobra.Command{
		Use:   "on-erc-1155-received",
		Short: "Call the OnERC1155Received view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if arg0Raw == "" {
				return fmt.Errorf("--arg-0 argument not specified")
			} else if !common.IsHexAddress(arg0Raw) {
				return fmt.Errorf("--arg-0 argument is not a valid Ethereum address")
			}
			arg0 = common.HexToAddress(arg0Raw)

			if arg1Raw == "" {
				return fmt.Errorf("--arg-1 argument not specified")
			} else if !common.IsHexAddress(arg1Raw) {
				return fmt.Errorf("--arg-1 argument is not a valid Ethereum address")
			}
			arg1 = common.HexToAddress(arg1Raw)

			if arg2Raw == "" {
				return fmt.Errorf("--arg-2 argument not specified")
			}
			arg2 = new(big.Int)
			arg2.SetString(arg2Raw, 0)

			if arg3Raw == "" {
				return fmt.Errorf("--arg-3 argument not specified")
			}
			arg3 = new(big.Int)
			arg3.SetString(arg3Raw, 0)

			var arg4Intermediate []byte

			var arg4IntermediateHexDecodeErr error
			arg4Intermediate, arg4IntermediateHexDecodeErr = hex.DecodeString(arg4Raw)
			if arg4IntermediateHexDecodeErr != nil {
				return arg4IntermediateHexDecodeErr
			}

			copy(arg4[:], arg4Intermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.OnERC1155Received(
				arg0,
				arg1,
				arg2,
				arg3,
				arg4,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument (common.Address)")
	cmd.Flags().StringVar(&arg1Raw, "arg-1", "", "arg-1 argument (common.Address)")
	cmd.Flags().StringVar(&arg2Raw, "arg-2", "", "arg-2 argument")
	cmd.Flags().StringVar(&arg3Raw, "arg-3", "", "arg-3 argument")
	cmd.Flags().StringVar(&arg4Raw, "arg-4", "", "arg-4 argument ([]byte)")

	return cmd
}
func CreateOnErc721ReceivedCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 common.Address
	var arg0Raw string
	var arg1 common.Address
	var arg1Raw string
	var arg2 *big.Int
	var arg2Raw string
	var arg3 []byte
	var arg3Raw string

	var capture0 [4]byte

	cmd := &cobra.Command{
		Use:   "on-erc-721-received",
		Short: "Call the OnERC721Received view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if arg0Raw == "" {
				return fmt.Errorf("--arg-0 argument not specified")
			} else if !common.IsHexAddress(arg0Raw) {
				return fmt.Errorf("--arg-0 argument is not a valid Ethereum address")
			}
			arg0 = common.HexToAddress(arg0Raw)

			if arg1Raw == "" {
				return fmt.Errorf("--arg-1 argument not specified")
			} else if !common.IsHexAddress(arg1Raw) {
				return fmt.Errorf("--arg-1 argument is not a valid Ethereum address")
			}
			arg1 = common.HexToAddress(arg1Raw)

			if arg2Raw == "" {
				return fmt.Errorf("--arg-2 argument not specified")
			}
			arg2 = new(big.Int)
			arg2.SetString(arg2Raw, 0)

			var arg3Intermediate []byte

			var arg3IntermediateHexDecodeErr error
			arg3Intermediate, arg3IntermediateHexDecodeErr = hex.DecodeString(arg3Raw)
			if arg3IntermediateHexDecodeErr != nil {
				return arg3IntermediateHexDecodeErr
			}

			copy(arg3[:], arg3Intermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.OnERC721Received(
				arg0,
				arg1,
				arg2,
				arg3,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument (common.Address)")
	cmd.Flags().StringVar(&arg1Raw, "arg-1", "", "arg-1 argument (common.Address)")
	cmd.Flags().StringVar(&arg2Raw, "arg-2", "", "arg-2 argument")
	cmd.Flags().StringVar(&arg3Raw, "arg-3", "", "arg-3 argument ([]byte)")

	return cmd
}
func CreateOwnerOfCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var tokenId *big.Int
	var tokenIdRaw string

	var capture0 common.Address

	cmd := &cobra.Command{
		Use:   "owner-of",
		Short: "Call the OwnerOf view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if tokenIdRaw == "" {
				return fmt.Errorf("--token-id argument not specified")
			}
			tokenId = new(big.Int)
			tokenId.SetString(tokenIdRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.OwnerOf(
				tokenId,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.Hex())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&tokenIdRaw, "token-id", "", "token-id argument")

	return cmd
}
func CreatePoolsCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 *big.Int
	var arg0Raw string

	var capture0 struct {
		Administrator   common.Address
		TokenType       *big.Int
		TokenAddress    common.Address
		TokenID         *big.Int
		Transferable    bool
		LockupSeconds   *big.Int
		CooldownSeconds *big.Int
	}

	cmd := &cobra.Command{
		Use:   "pools",
		Short: "Call the Pools view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if arg0Raw == "" {
				return fmt.Errorf("--arg-0 argument not specified")
			}
			arg0 = new(big.Int)
			arg0.SetString(arg0Raw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Pools(
				arg0,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument")

	return cmd
}
func CreatePositionMetadataAddressCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 common.Address

	cmd := &cobra.Command{
		Use:   "position-metadata-address",
		Short: "Call the PositionMetadataAddress view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.PositionMetadataAddress()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.Hex())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreatePositionsCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var arg0 *big.Int
	var arg0Raw string

	var capture0 struct {
		PoolID             *big.Int
		AmountOrTokenID    *big.Int
		StakeTimestamp     *big.Int
		UnstakeInitiatedAt *big.Int
	}

	cmd := &cobra.Command{
		Use:   "positions",
		Short: "Call the Positions view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if arg0Raw == "" {
				return fmt.Errorf("--arg-0 argument not specified")
			}
			arg0 = new(big.Int)
			arg0.SetString(arg0Raw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Positions(
				arg0,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %v\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&arg0Raw, "arg-0", "", "arg-0 argument")

	return cmd
}
func CreateSupportsInterfaceCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var interfaceId [4]byte
	var interfaceIdRaw string

	var capture0 bool

	cmd := &cobra.Command{
		Use:   "supports-interface",
		Short: "Call the SupportsInterface view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			var interfaceIdIntermediate []byte

			var interfaceIdIntermediateHexDecodeErr error
			interfaceIdIntermediate, interfaceIdIntermediateHexDecodeErr = hex.DecodeString(interfaceIdRaw)
			if interfaceIdIntermediateHexDecodeErr != nil {
				return interfaceIdIntermediateHexDecodeErr
			}

			copy(interfaceId[:], interfaceIdIntermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.SupportsInterface(
				interfaceId,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %t\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&interfaceIdRaw, "interface-id", "", "interface-id argument ([4]byte)")

	return cmd
}
func CreateSymbolCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 string

	cmd := &cobra.Command{
		Use:   "symbol",
		Short: "Call the Symbol view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.Symbol()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateTokenByIndexCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var index *big.Int
	var indexRaw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "token-by-index",
		Short: "Call the TokenByIndex view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if indexRaw == "" {
				return fmt.Errorf("--index argument not specified")
			}
			index = new(big.Int)
			index.SetString(indexRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.TokenByIndex(
				index,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&indexRaw, "index", "", "index argument")

	return cmd
}
func CreateTokenOfOwnerByIndexCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var owner common.Address
	var ownerRaw string
	var index *big.Int
	var indexRaw string

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "token-of-owner-by-index",
		Short: "Call the TokenOfOwnerByIndex view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if ownerRaw == "" {
				return fmt.Errorf("--owner argument not specified")
			} else if !common.IsHexAddress(ownerRaw) {
				return fmt.Errorf("--owner argument is not a valid Ethereum address")
			}
			owner = common.HexToAddress(ownerRaw)

			if indexRaw == "" {
				return fmt.Errorf("--index argument not specified")
			}
			index = new(big.Int)
			index.SetString(indexRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.TokenOfOwnerByIndex(
				owner,
				index,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&ownerRaw, "owner", "", "owner argument (common.Address)")
	cmd.Flags().StringVar(&indexRaw, "index", "", "index argument")

	return cmd
}
func CreateTokenUriCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var tokenId *big.Int
	var tokenIdRaw string

	var capture0 string

	cmd := &cobra.Command{
		Use:   "token-uri",
		Short: "Call the TokenURI view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			if tokenIdRaw == "" {
				return fmt.Errorf("--token-id argument not specified")
			}
			tokenId = new(big.Int)
			tokenId.SetString(tokenIdRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.TokenURI(
				tokenId,
			)
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0)

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	cmd.Flags().StringVar(&tokenIdRaw, "token-id", "", "token-id argument")

	return cmd
}
func CreateTotalPoolsCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "total-pools",
		Short: "Call the TotalPools view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.TotalPools()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateTotalPositionsCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "total-positions",
		Short: "Call the TotalPositions view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.TotalPositions()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}
func CreateTotalSupplyCommand() *cobra.Command {
	var contractAddressRaw, rpc string
	var contractAddress common.Address
	var timeout uint

	var blockNumberRaw, fromAddressRaw string
	var pending bool

	var capture0 *big.Int

	cmd := &cobra.Command{
		Use:   "total-supply",
		Short: "Call the TotalSupply view method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if contractAddressRaw == "" {
				return fmt.Errorf("--contract not specified")
			} else if !common.IsHexAddress(contractAddressRaw) {
				return fmt.Errorf("--contract is not a valid Ethereum address")
			}
			contractAddress = common.HexToAddress(contractAddressRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			callOpts := bind.CallOpts{}
			SetCallParametersFromArgs(&callOpts, pending, fromAddressRaw, blockNumberRaw)

			session := StakerCallerSession{
				Contract: &contract.StakerCaller,
				CallOpts: callOpts,
			}

			var callErr error
			capture0, callErr = session.TotalSupply()
			if callErr != nil {
				return callErr
			}

			cmd.Printf("0: %s\n", capture0.String())

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&blockNumberRaw, "block", "", "Block number at which to call the view method")
	cmd.Flags().BoolVar(&pending, "pending", false, "Set this flag if it's ok to call the view method against pending state")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&fromAddressRaw, "from", "", "Optional address for caller of the view method")

	return cmd
}

func CreateApproveCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var to0 common.Address
	var to0Raw string
	var tokenId *big.Int
	var tokenIdRaw string

	cmd := &cobra.Command{
		Use:   "approve",
		Short: "Execute the Approve method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if tokenIdRaw == "" {
				return fmt.Errorf("--token-id argument not specified")
			}
			tokenId = new(big.Int)
			tokenId.SetString(tokenIdRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "approve"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				to0,
				tokenId,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.Approve(

				to0,
				tokenId,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument (common.Address)")
	cmd.Flags().StringVar(&tokenIdRaw, "token-id", "", "token-id argument")

	return cmd
}
func CreateCreatePoolCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var tokenType *big.Int
	var tokenTypeRaw string
	var tokenAddress common.Address
	var tokenAddressRaw string
	var tokenID *big.Int
	var tokenIDRaw string
	var transferable bool
	var transferableRaw string
	var lockupSeconds *big.Int
	var lockupSecondsRaw string
	var cooldownSeconds *big.Int
	var cooldownSecondsRaw string
	var administrator common.Address
	var administratorRaw string

	cmd := &cobra.Command{
		Use:   "create-pool",
		Short: "Execute the CreatePool method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if tokenTypeRaw == "" {
				return fmt.Errorf("--token-type argument not specified")
			}
			tokenType = new(big.Int)
			tokenType.SetString(tokenTypeRaw, 0)

			if tokenAddressRaw == "" {
				return fmt.Errorf("--token-address argument not specified")
			} else if !common.IsHexAddress(tokenAddressRaw) {
				return fmt.Errorf("--token-address argument is not a valid Ethereum address")
			}
			tokenAddress = common.HexToAddress(tokenAddressRaw)

			if tokenIDRaw == "" {
				return fmt.Errorf("--token-id argument not specified")
			}
			tokenID = new(big.Int)
			tokenID.SetString(tokenIDRaw, 0)

			transferableRawLower := strings.ToLower(transferableRaw)
			switch transferableRawLower {
			case "true", "t", "y", "yes", "1":
				transferable = true
			case "false", "f", "n", "no", "0":
				transferable = false
			default:
				return fmt.Errorf("--transferable argument is not valid (value: %s)", transferableRaw)
			}

			if lockupSecondsRaw == "" {
				return fmt.Errorf("--lockup-seconds argument not specified")
			}
			lockupSeconds = new(big.Int)
			lockupSeconds.SetString(lockupSecondsRaw, 0)

			if cooldownSecondsRaw == "" {
				return fmt.Errorf("--cooldown-seconds argument not specified")
			}
			cooldownSeconds = new(big.Int)
			cooldownSeconds.SetString(cooldownSecondsRaw, 0)

			if administratorRaw == "" {
				return fmt.Errorf("--administrator argument not specified")
			} else if !common.IsHexAddress(administratorRaw) {
				return fmt.Errorf("--administrator argument is not a valid Ethereum address")
			}
			administrator = common.HexToAddress(administratorRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "createPool"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				tokenType,
				tokenAddress,
				tokenID,
				transferable,
				lockupSeconds,
				cooldownSeconds,
				administrator,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.CreatePool(

				tokenType,
				tokenAddress,
				tokenID,
				transferable,
				lockupSeconds,
				cooldownSeconds,
				administrator,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&tokenTypeRaw, "token-type", "", "token-type argument")
	cmd.Flags().StringVar(&tokenAddressRaw, "token-address", "", "token-address argument (common.Address)")
	cmd.Flags().StringVar(&tokenIDRaw, "token-id", "", "token-id argument")
	cmd.Flags().StringVar(&transferableRaw, "transferable", "", "transferable argument (true, t, y, yes, 1 OR false, f, n, no, 0)")
	cmd.Flags().StringVar(&lockupSecondsRaw, "lockup-seconds", "", "lockup-seconds argument")
	cmd.Flags().StringVar(&cooldownSecondsRaw, "cooldown-seconds", "", "cooldown-seconds argument")
	cmd.Flags().StringVar(&administratorRaw, "administrator", "", "administrator argument (common.Address)")

	return cmd
}
func CreateInitiateUnstakeCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var positionTokenID *big.Int
	var positionTokenIDRaw string

	cmd := &cobra.Command{
		Use:   "initiate-unstake",
		Short: "Execute the InitiateUnstake method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if positionTokenIDRaw == "" {
				return fmt.Errorf("--position-token-id argument not specified")
			}
			positionTokenID = new(big.Int)
			positionTokenID.SetString(positionTokenIDRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "initiateUnstake"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				positionTokenID,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.InitiateUnstake(

				positionTokenID,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&positionTokenIDRaw, "position-token-id", "", "position-token-id argument")

	return cmd
}
func CreateSafeTransferFromCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var from0 common.Address
	var from0Raw string
	var to0 common.Address
	var to0Raw string
	var tokenId *big.Int
	var tokenIdRaw string

	cmd := &cobra.Command{
		Use:   "safe-transfer-from",
		Short: "Execute the SafeTransferFrom method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if from0Raw == "" {
				return fmt.Errorf("--from-0 argument not specified")
			} else if !common.IsHexAddress(from0Raw) {
				return fmt.Errorf("--from-0 argument is not a valid Ethereum address")
			}
			from0 = common.HexToAddress(from0Raw)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if tokenIdRaw == "" {
				return fmt.Errorf("--token-id argument not specified")
			}
			tokenId = new(big.Int)
			tokenId.SetString(tokenIdRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "safeTransferFrom"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				from0,
				to0,
				tokenId,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.SafeTransferFrom(

				from0,
				to0,
				tokenId,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&from0Raw, "from-0", "", "from-0 argument (common.Address)")
	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument (common.Address)")
	cmd.Flags().StringVar(&tokenIdRaw, "token-id", "", "token-id argument")

	return cmd
}
func CreateSafeTransferFrom0Command() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var from0 common.Address
	var from0Raw string
	var to0 common.Address
	var to0Raw string
	var tokenId *big.Int
	var tokenIdRaw string
	var data []byte
	var dataRaw string

	cmd := &cobra.Command{
		Use:   "safe-transfer-from-0",
		Short: "Execute the SafeTransferFrom0 method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if from0Raw == "" {
				return fmt.Errorf("--from-0 argument not specified")
			} else if !common.IsHexAddress(from0Raw) {
				return fmt.Errorf("--from-0 argument is not a valid Ethereum address")
			}
			from0 = common.HexToAddress(from0Raw)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if tokenIdRaw == "" {
				return fmt.Errorf("--token-id argument not specified")
			}
			tokenId = new(big.Int)
			tokenId.SetString(tokenIdRaw, 0)

			var dataIntermediate []byte

			var dataIntermediateHexDecodeErr error
			dataIntermediate, dataIntermediateHexDecodeErr = hex.DecodeString(dataRaw)
			if dataIntermediateHexDecodeErr != nil {
				return dataIntermediateHexDecodeErr
			}

			copy(data[:], dataIntermediate)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "safeTransferFrom0"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				from0,
				to0,
				tokenId,
				data,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.SafeTransferFrom0(

				from0,
				to0,
				tokenId,
				data,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&from0Raw, "from-0", "", "from-0 argument (common.Address)")
	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument (common.Address)")
	cmd.Flags().StringVar(&tokenIdRaw, "token-id", "", "token-id argument")
	cmd.Flags().StringVar(&dataRaw, "data", "", "data argument ([]byte)")

	return cmd
}
func CreateSetApprovalForAllCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var operator common.Address
	var operatorRaw string
	var approved bool
	var approvedRaw string

	cmd := &cobra.Command{
		Use:   "set-approval-for-all",
		Short: "Execute the SetApprovalForAll method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if operatorRaw == "" {
				return fmt.Errorf("--operator argument not specified")
			} else if !common.IsHexAddress(operatorRaw) {
				return fmt.Errorf("--operator argument is not a valid Ethereum address")
			}
			operator = common.HexToAddress(operatorRaw)

			approvedRawLower := strings.ToLower(approvedRaw)
			switch approvedRawLower {
			case "true", "t", "y", "yes", "1":
				approved = true
			case "false", "f", "n", "no", "0":
				approved = false
			default:
				return fmt.Errorf("--approved argument is not valid (value: %s)", approvedRaw)
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "setApprovalForAll"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				operator,
				approved,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.SetApprovalForAll(

				operator,
				approved,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&operatorRaw, "operator", "", "operator argument (common.Address)")
	cmd.Flags().StringVar(&approvedRaw, "approved", "", "approved argument (true, t, y, yes, 1 OR false, f, n, no, 0)")

	return cmd
}
func CreateStakeErc1155Command() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var positionHolder common.Address
	var positionHolderRaw string
	var poolID *big.Int
	var poolIDRaw string
	var amount *big.Int
	var amountRaw string

	cmd := &cobra.Command{
		Use:   "stake-erc-1155",
		Short: "Execute the StakeERC1155 method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if positionHolderRaw == "" {
				return fmt.Errorf("--position-holder argument not specified")
			} else if !common.IsHexAddress(positionHolderRaw) {
				return fmt.Errorf("--position-holder argument is not a valid Ethereum address")
			}
			positionHolder = common.HexToAddress(positionHolderRaw)

			if poolIDRaw == "" {
				return fmt.Errorf("--pool-id argument not specified")
			}
			poolID = new(big.Int)
			poolID.SetString(poolIDRaw, 0)

			if amountRaw == "" {
				return fmt.Errorf("--amount argument not specified")
			}
			amount = new(big.Int)
			amount.SetString(amountRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "stakeErc1155"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				positionHolder,
				poolID,
				amount,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.StakeERC1155(

				positionHolder,
				poolID,
				amount,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&positionHolderRaw, "position-holder", "", "position-holder argument (common.Address)")
	cmd.Flags().StringVar(&poolIDRaw, "pool-id", "", "pool-id argument")
	cmd.Flags().StringVar(&amountRaw, "amount", "", "amount argument")

	return cmd
}
func CreateStakeErc20Command() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var positionHolder common.Address
	var positionHolderRaw string
	var poolID *big.Int
	var poolIDRaw string
	var amount *big.Int
	var amountRaw string

	cmd := &cobra.Command{
		Use:   "stake-erc-20",
		Short: "Execute the StakeERC20 method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if positionHolderRaw == "" {
				return fmt.Errorf("--position-holder argument not specified")
			} else if !common.IsHexAddress(positionHolderRaw) {
				return fmt.Errorf("--position-holder argument is not a valid Ethereum address")
			}
			positionHolder = common.HexToAddress(positionHolderRaw)

			if poolIDRaw == "" {
				return fmt.Errorf("--pool-id argument not specified")
			}
			poolID = new(big.Int)
			poolID.SetString(poolIDRaw, 0)

			if amountRaw == "" {
				return fmt.Errorf("--amount argument not specified")
			}
			amount = new(big.Int)
			amount.SetString(amountRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "stakeErc20"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				positionHolder,
				poolID,
				amount,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.StakeERC20(

				positionHolder,
				poolID,
				amount,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&positionHolderRaw, "position-holder", "", "position-holder argument (common.Address)")
	cmd.Flags().StringVar(&poolIDRaw, "pool-id", "", "pool-id argument")
	cmd.Flags().StringVar(&amountRaw, "amount", "", "amount argument")

	return cmd
}
func CreateStakeErc721Command() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var positionHolder common.Address
	var positionHolderRaw string
	var poolID *big.Int
	var poolIDRaw string
	var tokenID *big.Int
	var tokenIDRaw string

	cmd := &cobra.Command{
		Use:   "stake-erc-721",
		Short: "Execute the StakeERC721 method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if positionHolderRaw == "" {
				return fmt.Errorf("--position-holder argument not specified")
			} else if !common.IsHexAddress(positionHolderRaw) {
				return fmt.Errorf("--position-holder argument is not a valid Ethereum address")
			}
			positionHolder = common.HexToAddress(positionHolderRaw)

			if poolIDRaw == "" {
				return fmt.Errorf("--pool-id argument not specified")
			}
			poolID = new(big.Int)
			poolID.SetString(poolIDRaw, 0)

			if tokenIDRaw == "" {
				return fmt.Errorf("--token-id argument not specified")
			}
			tokenID = new(big.Int)
			tokenID.SetString(tokenIDRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "stakeErc721"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				positionHolder,
				poolID,
				tokenID,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.StakeERC721(

				positionHolder,
				poolID,
				tokenID,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&positionHolderRaw, "position-holder", "", "position-holder argument (common.Address)")
	cmd.Flags().StringVar(&poolIDRaw, "pool-id", "", "pool-id argument")
	cmd.Flags().StringVar(&tokenIDRaw, "token-id", "", "token-id argument")

	return cmd
}
func CreateStakeNativeCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var positionHolder common.Address
	var positionHolderRaw string
	var poolID *big.Int
	var poolIDRaw string

	cmd := &cobra.Command{
		Use:   "stake-native",
		Short: "Execute the StakeNative method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if positionHolderRaw == "" {
				return fmt.Errorf("--position-holder argument not specified")
			} else if !common.IsHexAddress(positionHolderRaw) {
				return fmt.Errorf("--position-holder argument is not a valid Ethereum address")
			}
			positionHolder = common.HexToAddress(positionHolderRaw)

			if poolIDRaw == "" {
				return fmt.Errorf("--pool-id argument not specified")
			}
			poolID = new(big.Int)
			poolID.SetString(poolIDRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "stakeNative"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				positionHolder,
				poolID,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.StakeNative(

				positionHolder,
				poolID,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&positionHolderRaw, "position-holder", "", "position-holder argument (common.Address)")
	cmd.Flags().StringVar(&poolIDRaw, "pool-id", "", "pool-id argument")

	return cmd
}
func CreateTransferFromCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var from0 common.Address
	var from0Raw string
	var to0 common.Address
	var to0Raw string
	var tokenId *big.Int
	var tokenIdRaw string

	cmd := &cobra.Command{
		Use:   "transfer-from",
		Short: "Execute the TransferFrom method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if from0Raw == "" {
				return fmt.Errorf("--from-0 argument not specified")
			} else if !common.IsHexAddress(from0Raw) {
				return fmt.Errorf("--from-0 argument is not a valid Ethereum address")
			}
			from0 = common.HexToAddress(from0Raw)

			if to0Raw == "" {
				return fmt.Errorf("--to-0 argument not specified")
			} else if !common.IsHexAddress(to0Raw) {
				return fmt.Errorf("--to-0 argument is not a valid Ethereum address")
			}
			to0 = common.HexToAddress(to0Raw)

			if tokenIdRaw == "" {
				return fmt.Errorf("--token-id argument not specified")
			}
			tokenId = new(big.Int)
			tokenId.SetString(tokenIdRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "transferFrom"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				from0,
				to0,
				tokenId,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.TransferFrom(

				from0,
				to0,
				tokenId,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&from0Raw, "from-0", "", "from-0 argument (common.Address)")
	cmd.Flags().StringVar(&to0Raw, "to-0", "", "to-0 argument (common.Address)")
	cmd.Flags().StringVar(&tokenIdRaw, "token-id", "", "token-id argument")

	return cmd
}
func CreateTransferPoolAdministrationCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var poolID *big.Int
	var poolIDRaw string
	var newAdministrator common.Address
	var newAdministratorRaw string

	cmd := &cobra.Command{
		Use:   "transfer-pool-administration",
		Short: "Execute the TransferPoolAdministration method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if poolIDRaw == "" {
				return fmt.Errorf("--pool-id argument not specified")
			}
			poolID = new(big.Int)
			poolID.SetString(poolIDRaw, 0)

			if newAdministratorRaw == "" {
				return fmt.Errorf("--new-administrator argument not specified")
			} else if !common.IsHexAddress(newAdministratorRaw) {
				return fmt.Errorf("--new-administrator argument is not a valid Ethereum address")
			}
			newAdministrator = common.HexToAddress(newAdministratorRaw)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "transferPoolAdministration"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				poolID,
				newAdministrator,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.TransferPoolAdministration(

				poolID,
				newAdministrator,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&poolIDRaw, "pool-id", "", "pool-id argument")
	cmd.Flags().StringVar(&newAdministratorRaw, "new-administrator", "", "new-administrator argument (common.Address)")

	return cmd
}
func CreateUnstakeCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var positionTokenID *big.Int
	var positionTokenIDRaw string

	cmd := &cobra.Command{
		Use:   "unstake",
		Short: "Execute the Unstake method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if positionTokenIDRaw == "" {
				return fmt.Errorf("--position-token-id argument not specified")
			}
			positionTokenID = new(big.Int)
			positionTokenID.SetString(positionTokenIDRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "unstake"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				positionTokenID,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.Unstake(

				positionTokenID,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&positionTokenIDRaw, "position-token-id", "", "position-token-id argument")

	return cmd
}
func CreateUpdatePoolConfigurationCommand() *cobra.Command {
	var keyfile, nonce, password, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, rpc, contractAddressRaw, safeFunction, safeNonceRaw string
	var gasLimit uint64
	var simulate bool
	var timeout uint
	var contractAddress common.Address
	var safeAddress, safeApi string
	var safeOperationType uint8
	var safeNonce *big.Int
	var calldata bool

	var poolID *big.Int
	var poolIDRaw string
	var changeTransferability bool
	var changeTransferabilityRaw string
	var transferable bool
	var transferableRaw string
	var changeLockup bool
	var changeLockupRaw string
	var lockupSeconds *big.Int
	var lockupSecondsRaw string
	var changeCooldown bool
	var changeCooldownRaw string
	var cooldownSeconds *big.Int
	var cooldownSecondsRaw string

	cmd := &cobra.Command{
		Use:   "update-pool-configuration",
		Short: "Execute the UpdatePoolConfiguration method on a Staker contract",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !calldata {
				if contractAddressRaw == "" {
					return fmt.Errorf("--contract not specified")
				} else if !common.IsHexAddress(contractAddressRaw) {
					return fmt.Errorf("--contract is not a valid Ethereum address")
				}
				contractAddress = common.HexToAddress(contractAddressRaw)

				if keyfile == "" {
					return fmt.Errorf("--keystore not specified (this should be a path to an Ethereum account keystore file)")
				}

				if rpc == "" {
					return fmt.Errorf("--rpc not specified (this should be a URL to an Ethereum JSONRPC API)")
				}
			}

			if safeAddress != "" {
				if !common.IsHexAddress(safeAddress) {
					return fmt.Errorf("--safe is not a valid Ethereum address")
				}
				if safeApi == "" {
					client, clientErr := NewClient(rpc)
					if clientErr != nil {
						return clientErr
					}
					chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
					defer cancelChainIDCtx()
					chainID, chainIDErr := client.ChainID(chainIDCtx)
					if chainIDErr != nil {
						return chainIDErr
					}
					safeApi = fmt.Sprintf("https://safe-client.safe.global/v1/chains/%s/transactions/%s/propose", chainID.String(), safeAddress)
					fmt.Println("--safe-api not specified, using default (", safeApi, ")")
				}

				if SafeOperationType(safeOperationType).String() == "Unknown" {
					return fmt.Errorf("--safe-operation must be 0 (Call) or 1 (DelegateCall)")
				}

				if safeNonceRaw == "" {
					fmt.Println("--safe-nonce not specified, fetching nonce from Safe contract")
				} else {
					safeNonce = new(big.Int)
					_, ok := safeNonce.SetString(safeNonceRaw, 0)
					if !ok {
						return fmt.Errorf("--safe-nonce is not a valid big integer")
					}
				}
			}

			if poolIDRaw == "" {
				return fmt.Errorf("--pool-id argument not specified")
			}
			poolID = new(big.Int)
			poolID.SetString(poolIDRaw, 0)

			changeTransferabilityRawLower := strings.ToLower(changeTransferabilityRaw)
			switch changeTransferabilityRawLower {
			case "true", "t", "y", "yes", "1":
				changeTransferability = true
			case "false", "f", "n", "no", "0":
				changeTransferability = false
			default:
				return fmt.Errorf("--change-transferability argument is not valid (value: %s)", changeTransferabilityRaw)
			}

			transferableRawLower := strings.ToLower(transferableRaw)
			switch transferableRawLower {
			case "true", "t", "y", "yes", "1":
				transferable = true
			case "false", "f", "n", "no", "0":
				transferable = false
			default:
				return fmt.Errorf("--transferable argument is not valid (value: %s)", transferableRaw)
			}

			changeLockupRawLower := strings.ToLower(changeLockupRaw)
			switch changeLockupRawLower {
			case "true", "t", "y", "yes", "1":
				changeLockup = true
			case "false", "f", "n", "no", "0":
				changeLockup = false
			default:
				return fmt.Errorf("--change-lockup argument is not valid (value: %s)", changeLockupRaw)
			}

			if lockupSecondsRaw == "" {
				return fmt.Errorf("--lockup-seconds argument not specified")
			}
			lockupSeconds = new(big.Int)
			lockupSeconds.SetString(lockupSecondsRaw, 0)

			changeCooldownRawLower := strings.ToLower(changeCooldownRaw)
			switch changeCooldownRawLower {
			case "true", "t", "y", "yes", "1":
				changeCooldown = true
			case "false", "f", "n", "no", "0":
				changeCooldown = false
			default:
				return fmt.Errorf("--change-cooldown argument is not valid (value: %s)", changeCooldownRaw)
			}

			if cooldownSecondsRaw == "" {
				return fmt.Errorf("--cooldown-seconds argument not specified")
			}
			cooldownSeconds = new(big.Int)
			cooldownSeconds.SetString(cooldownSecondsRaw, 0)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			abi, err := StakerMetaData.GetAbi()
			if err != nil {
				return fmt.Errorf("failed to get ABI: %v", err)
			}

			// Generate transaction data (override method name if safe function is specified)
			methodName := "updatePoolConfiguration"
			if safeFunction != "" {
				methodName = safeFunction
			}

			txCalldata, err := abi.Pack(
				methodName,
				poolID,
				changeTransferability,
				transferable,
				changeLockup,
				lockupSeconds,
				changeCooldown,
				cooldownSeconds,
			)

			if err != nil {
				return err
			}

			if calldata {
				txCalldataHex := hex.EncodeToString(txCalldata)
				cmd.Println(txCalldataHex)
				return nil
			}

			client, clientErr := NewClient(rpc)
			if clientErr != nil {
				return clientErr
			}

			key, keyErr := KeyFromFile(keyfile, password)
			if keyErr != nil {
				return keyErr
			}

			chainIDCtx, cancelChainIDCtx := NewChainContext(timeout)
			defer cancelChainIDCtx()
			chainID, chainIDErr := client.ChainID(chainIDCtx)
			if chainIDErr != nil {
				return chainIDErr
			}

			transactionOpts, transactionOptsErr := bind.NewKeyedTransactorWithChainID(key.PrivateKey, chainID)
			if transactionOptsErr != nil {
				return transactionOptsErr
			}

			SetTransactionParametersFromArgs(transactionOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas, gasLimit, simulate)

			contract, contractErr := NewStaker(contractAddress, client)
			if contractErr != nil {
				return contractErr
			}

			session := StakerTransactorSession{
				Contract:     &contract.StakerTransactor,
				TransactOpts: *transactionOpts,
			}

			if safeAddress != "" {
				// Create Safe proposal for transaction
				value := transactionOpts.Value
				if value == nil {
					value = big.NewInt(0)
				}

				err = CreateSafeProposal(client, key, common.HexToAddress(safeAddress), contractAddress, txCalldata, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
				if err != nil {
					return fmt.Errorf("failed to create Safe proposal: %v", err)
				}

				return nil
			}

			transaction, err := session.UpdatePoolConfiguration(

				poolID,
				changeTransferability,
				transferable,
				changeLockup,
				lockupSeconds,
				changeCooldown,
				cooldownSeconds,
			)
			if err != nil {
				return err
			}

			cmd.Printf("Transaction hash: %s\n", transaction.Hash().Hex())
			if transactionOpts.NoSend {
				estimationMessage := ethereum.CallMsg{
					From: transactionOpts.From,
					To:   &contractAddress,
					Data: transaction.Data(),
				}

				gasEstimationCtx, cancelGasEstimationCtx := NewChainContext(timeout)
				defer cancelGasEstimationCtx()

				gasEstimate, gasEstimateErr := client.EstimateGas(gasEstimationCtx, estimationMessage)
				if gasEstimateErr != nil {
					return gasEstimateErr
				}

				transactionBinary, transactionBinaryErr := transaction.MarshalBinary()
				if transactionBinaryErr != nil {
					return transactionBinaryErr
				}
				transactionBinaryHex := hex.EncodeToString(transactionBinary)

				cmd.Printf("Transaction: %s\nEstimated gas: %d\n", transactionBinaryHex, gasEstimate)
			} else {
				cmd.Println("Transaction submitted")
			}

			return nil
		},
	}

	cmd.Flags().StringVar(&rpc, "rpc", "", "URL of the JSONRPC API to use")
	cmd.Flags().StringVar(&keyfile, "keyfile", "", "Path to the keystore file to use for the transaction")
	cmd.Flags().StringVar(&password, "password", "", "Password to use to unlock the keystore (if not specified, you will be prompted for the password when the command executes)")
	cmd.Flags().StringVar(&nonce, "nonce", "", "Nonce to use for the transaction")
	cmd.Flags().StringVar(&value, "value", "", "Value to send with the transaction")
	cmd.Flags().StringVar(&gasPrice, "gas-price", "", "Gas price to use for the transaction")
	cmd.Flags().StringVar(&maxFeePerGas, "max-fee-per-gas", "", "Maximum fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().StringVar(&maxPriorityFeePerGas, "max-priority-fee-per-gas", "", "Maximum priority fee per gas to use for the (EIP-1559) transaction")
	cmd.Flags().Uint64Var(&gasLimit, "gas-limit", 0, "Gas limit for the transaction")
	cmd.Flags().BoolVar(&simulate, "simulate", false, "Simulate the transaction without sending it")
	cmd.Flags().UintVar(&timeout, "timeout", 60, "Timeout (in seconds) for interactions with the JSONRPC API")
	cmd.Flags().StringVar(&contractAddressRaw, "contract", "", "Address of the contract to interact with")
	cmd.Flags().StringVar(&safeAddress, "safe", "", "Address of the Safe contract")
	cmd.Flags().StringVar(&safeApi, "safe-api", "", "Safe API for the Safe Transaction Service (optional)")
	cmd.Flags().Uint8Var(&safeOperationType, "safe-operation", 0, "Safe operation type: 0 (Call) or 1 (DelegateCall)")
	cmd.Flags().StringVar(&safeFunction, "safe-function", "", "Safe function overrider to use for the transaction (optional)")
	cmd.Flags().StringVar(&safeNonceRaw, "safe-nonce", "", "Safe nonce overrider for the transaction (optional)")
	cmd.Flags().BoolVar(&calldata, "calldata", false, "Set this flag if want to return the calldata instead of sending the transaction")

	cmd.Flags().StringVar(&poolIDRaw, "pool-id", "", "pool-id argument")
	cmd.Flags().StringVar(&changeTransferabilityRaw, "change-transferability", "", "change-transferability argument (true, t, y, yes, 1 OR false, f, n, no, 0)")
	cmd.Flags().StringVar(&transferableRaw, "transferable", "", "transferable argument (true, t, y, yes, 1 OR false, f, n, no, 0)")
	cmd.Flags().StringVar(&changeLockupRaw, "change-lockup", "", "change-lockup argument (true, t, y, yes, 1 OR false, f, n, no, 0)")
	cmd.Flags().StringVar(&lockupSecondsRaw, "lockup-seconds", "", "lockup-seconds argument")
	cmd.Flags().StringVar(&changeCooldownRaw, "change-cooldown", "", "change-cooldown argument (true, t, y, yes, 1 OR false, f, n, no, 0)")
	cmd.Flags().StringVar(&cooldownSecondsRaw, "cooldown-seconds", "", "cooldown-seconds argument")

	return cmd
}

var ErrNoRPCURL error = errors.New("no RPC URL provided -- please pass an RPC URL from the command line or set the STAKER_RPC_URL environment variable")

// Generates an Ethereum client to the JSONRPC API at the given URL. If rpcURL is empty, then it
// attempts to read the RPC URL from the STAKER_RPC_URL environment variable. If that is empty,
// too, then it returns an error.
func NewClient(rpcURL string) (*ethclient.Client, error) {
	if rpcURL == "" {
		rpcURL = os.Getenv("STAKER_RPC_URL")
	}

	if rpcURL == "" {
		return nil, ErrNoRPCURL
	}

	client, err := ethclient.Dial(rpcURL)
	return client, err
}

// Creates a new context to be used when interacting with the chain client.
func NewChainContext(timeout uint) (context.Context, context.CancelFunc) {
	baseCtx := context.Background()
	parsedTimeout := time.Duration(timeout) * time.Second
	ctx, cancel := context.WithTimeout(baseCtx, parsedTimeout)
	return ctx, cancel
}

// Unlocks a key from a keystore (byte contents of a keystore file) with the given password.
func UnlockKeystore(keystoreData []byte, password string) (*keystore.Key, error) {
	key, err := keystore.DecryptKey(keystoreData, password)
	return key, err
}

// Loads a key from file, prompting the user for the password if it is not provided as a function argument.
func KeyFromFile(keystoreFile string, password string) (*keystore.Key, error) {
	var emptyKey *keystore.Key
	keystoreContent, readErr := os.ReadFile(keystoreFile)
	if readErr != nil {
		return emptyKey, readErr
	}

	// If password is "", prompt user for password.
	if password == "" {
		fmt.Printf("Please provide a password for keystore (%s): ", keystoreFile)
		passwordRaw, inputErr := term.ReadPassword(int(os.Stdin.Fd()))
		if inputErr != nil {
			return emptyKey, fmt.Errorf("error reading password: %s", inputErr.Error())
		}
		fmt.Print("\n")
		password = string(passwordRaw)
	}

	key, err := UnlockKeystore(keystoreContent, password)
	return key, err
}

// This method is used to set the parameters on a view call from command line arguments (represented mostly as
// strings).
func SetCallParametersFromArgs(opts *bind.CallOpts, pending bool, fromAddress, blockNumber string) {
	if pending {
		opts.Pending = true
	}

	if fromAddress != "" {
		opts.From = common.HexToAddress(fromAddress)
	}

	if blockNumber != "" {
		opts.BlockNumber = new(big.Int)
		opts.BlockNumber.SetString(blockNumber, 0)
	}
}

// This method is used to set the parameters on a transaction from command line arguments (represented mostly as
// strings).
func SetTransactionParametersFromArgs(opts *bind.TransactOpts, nonce, value, gasPrice, maxFeePerGas, maxPriorityFeePerGas string, gasLimit uint64, noSend bool) {
	if nonce != "" {
		opts.Nonce = new(big.Int)
		opts.Nonce.SetString(nonce, 0)
	}

	if value != "" {
		opts.Value = new(big.Int)
		opts.Value.SetString(value, 0)
	}

	if gasPrice != "" {
		opts.GasPrice = new(big.Int)
		opts.GasPrice.SetString(gasPrice, 0)
	}

	if maxFeePerGas != "" {
		opts.GasFeeCap = new(big.Int)
		opts.GasFeeCap.SetString(maxFeePerGas, 0)
	}

	if maxPriorityFeePerGas != "" {
		opts.GasTipCap = new(big.Int)
		opts.GasTipCap.SetString(maxPriorityFeePerGas, 0)
	}

	if gasLimit != 0 {
		opts.GasLimit = gasLimit
	}

	opts.NoSend = noSend
}

func CreateStakerCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "staker",
		Short: "Interact with the Staker contract",
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	cmd.SetOut(os.Stdout)

	DeployGroup := &cobra.Group{
		ID: "deploy", Title: "Commands which deploy contracts",
	}
	cmd.AddGroup(DeployGroup)
	ViewGroup := &cobra.Group{
		ID: "view", Title: "Commands which view contract state",
	}
	TransactGroup := &cobra.Group{
		ID: "transact", Title: "Commands which submit transactions",
	}
	cmd.AddGroup(ViewGroup, TransactGroup)

	cmdDeployStaker := CreateStakerDeploymentCommand()
	cmdDeployStaker.GroupID = DeployGroup.ID
	cmd.AddCommand(cmdDeployStaker)

	cmdViewBalanceOf := CreateBalanceOfCommand()
	cmdViewBalanceOf.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewBalanceOf)
	cmdViewCurrentAmountInPool := CreateCurrentAmountInPoolCommand()
	cmdViewCurrentAmountInPool.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewCurrentAmountInPool)
	cmdViewCurrentPositionsInPool := CreateCurrentPositionsInPoolCommand()
	cmdViewCurrentPositionsInPool.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewCurrentPositionsInPool)
	cmdViewERC1155TOKENTYPE := CreateErc1155TokentypeCommand()
	cmdViewERC1155TOKENTYPE.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewERC1155TOKENTYPE)
	cmdViewERC20TOKENTYPE := CreateErc20TokentypeCommand()
	cmdViewERC20TOKENTYPE.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewERC20TOKENTYPE)
	cmdViewERC721TOKENTYPE := CreateErc721TokentypeCommand()
	cmdViewERC721TOKENTYPE.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewERC721TOKENTYPE)
	cmdViewGetApproved := CreateGetApprovedCommand()
	cmdViewGetApproved.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewGetApproved)
	cmdViewIsApprovedForAll := CreateIsApprovedForAllCommand()
	cmdViewIsApprovedForAll.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewIsApprovedForAll)
	cmdViewNATIVETOKENTYPE := CreateNativetokentypeCommand()
	cmdViewNATIVETOKENTYPE.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewNATIVETOKENTYPE)
	cmdViewName := CreateNameCommand()
	cmdViewName.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewName)
	cmdViewOnERC1155Received := CreateOnErc1155ReceivedCommand()
	cmdViewOnERC1155Received.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewOnERC1155Received)
	cmdViewOnERC721Received := CreateOnErc721ReceivedCommand()
	cmdViewOnERC721Received.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewOnERC721Received)
	cmdViewOwnerOf := CreateOwnerOfCommand()
	cmdViewOwnerOf.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewOwnerOf)
	cmdViewPools := CreatePoolsCommand()
	cmdViewPools.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewPools)
	cmdViewPositionMetadataAddress := CreatePositionMetadataAddressCommand()
	cmdViewPositionMetadataAddress.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewPositionMetadataAddress)
	cmdViewPositions := CreatePositionsCommand()
	cmdViewPositions.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewPositions)
	cmdViewSupportsInterface := CreateSupportsInterfaceCommand()
	cmdViewSupportsInterface.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewSupportsInterface)
	cmdViewSymbol := CreateSymbolCommand()
	cmdViewSymbol.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewSymbol)
	cmdViewTokenByIndex := CreateTokenByIndexCommand()
	cmdViewTokenByIndex.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewTokenByIndex)
	cmdViewTokenOfOwnerByIndex := CreateTokenOfOwnerByIndexCommand()
	cmdViewTokenOfOwnerByIndex.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewTokenOfOwnerByIndex)
	cmdViewTokenURI := CreateTokenUriCommand()
	cmdViewTokenURI.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewTokenURI)
	cmdViewTotalPools := CreateTotalPoolsCommand()
	cmdViewTotalPools.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewTotalPools)
	cmdViewTotalPositions := CreateTotalPositionsCommand()
	cmdViewTotalPositions.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewTotalPositions)
	cmdViewTotalSupply := CreateTotalSupplyCommand()
	cmdViewTotalSupply.GroupID = ViewGroup.ID
	cmd.AddCommand(cmdViewTotalSupply)

	cmdTransactApprove := CreateApproveCommand()
	cmdTransactApprove.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactApprove)
	cmdTransactCreatePool := CreateCreatePoolCommand()
	cmdTransactCreatePool.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactCreatePool)
	cmdTransactInitiateUnstake := CreateInitiateUnstakeCommand()
	cmdTransactInitiateUnstake.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactInitiateUnstake)
	cmdTransactSafeTransferFrom := CreateSafeTransferFromCommand()
	cmdTransactSafeTransferFrom.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSafeTransferFrom)
	cmdTransactSafeTransferFrom0 := CreateSafeTransferFrom0Command()
	cmdTransactSafeTransferFrom0.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSafeTransferFrom0)
	cmdTransactSetApprovalForAll := CreateSetApprovalForAllCommand()
	cmdTransactSetApprovalForAll.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactSetApprovalForAll)
	cmdTransactStakeERC1155 := CreateStakeErc1155Command()
	cmdTransactStakeERC1155.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactStakeERC1155)
	cmdTransactStakeERC20 := CreateStakeErc20Command()
	cmdTransactStakeERC20.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactStakeERC20)
	cmdTransactStakeERC721 := CreateStakeErc721Command()
	cmdTransactStakeERC721.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactStakeERC721)
	cmdTransactStakeNative := CreateStakeNativeCommand()
	cmdTransactStakeNative.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactStakeNative)
	cmdTransactTransferFrom := CreateTransferFromCommand()
	cmdTransactTransferFrom.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactTransferFrom)
	cmdTransactTransferPoolAdministration := CreateTransferPoolAdministrationCommand()
	cmdTransactTransferPoolAdministration.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactTransferPoolAdministration)
	cmdTransactUnstake := CreateUnstakeCommand()
	cmdTransactUnstake.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactUnstake)
	cmdTransactUpdatePoolConfiguration := CreateUpdatePoolConfigurationCommand()
	cmdTransactUpdatePoolConfiguration.GroupID = TransactGroup.ID
	cmd.AddCommand(cmdTransactUpdatePoolConfiguration)

	return cmd
}

// SafeOperationType represents the type of operation for a Safe transaction
type SafeOperationType uint8

const (
	Call         SafeOperationType = 0
	DelegateCall SafeOperationType = 1
)

// String returns the string representation of the SafeOperationType
func (o SafeOperationType) String() string {
	switch o {
	case Call:
		return "Call"
	case DelegateCall:
		return "DelegateCall"
	default:
		return "Unknown"
	}
}

// SafeTransactionData represents the data for a Safe transaction
type SafeTransactionData struct {
	To             string            `json:"to"`
	Value          string            `json:"value"`
	Data           string            `json:"data"`
	Operation      SafeOperationType `json:"operation"`
	SafeTxGas      uint64            `json:"safeTxGas"`
	BaseGas        uint64            `json:"baseGas"`
	GasPrice       string            `json:"gasPrice"`
	GasToken       string            `json:"gasToken"`
	RefundReceiver string            `json:"refundReceiver"`
	Nonce          *big.Int          `json:"nonce"`
	SafeTxHash     string            `json:"safeTxHash"`
	Sender         string            `json:"sender"`
	Signature      string            `json:"signature"`
	Origin         string            `json:"origin"`
}

const (
	NativeTokenAddress = "0x0000000000000000000000000000000000000000"
)

func DeployWithSafe(client *ethclient.Client, key *keystore.Key, safeAddress common.Address, factoryAddress common.Address, value *big.Int, safeApi string, deployBytecode []byte, safeOperationType SafeOperationType, salt [32]byte, safeNonce *big.Int) error {
	abi, err := CreateCall.CreateCallMetaData.GetAbi()
	if err != nil {
		return fmt.Errorf("failed to get ABI: %v", err)
	}

	safeCreateCallTxData, err := abi.Pack("performCreate2", value, deployBytecode, salt)
	if err != nil {
		return fmt.Errorf("failed to pack performCreate2 transaction: %v", err)
	}

	return CreateSafeProposal(client, key, safeAddress, factoryAddress, safeCreateCallTxData, value, safeApi, SafeOperationType(safeOperationType), safeNonce)
}

func PredictDeploymentAddressSafe(from common.Address, salt [32]byte, deployBytecode []byte) (common.Address, error) {
	// Calculate the hash of the init code (deployment bytecode)
	initCodeHash := crypto.Keccak256(deployBytecode)

	// Calculate the CREATE2 address
	deployedAddress := crypto.CreateAddress2(from, salt, initCodeHash)

	return deployedAddress, nil
}

func CreateSafeProposal(client *ethclient.Client, key *keystore.Key, safeAddress common.Address, to common.Address, data []byte, value *big.Int, safeApi string, safeOperationType SafeOperationType, safeNonce *big.Int) error {
	chainID, err := client.ChainID(context.Background())
	if err != nil {
		return fmt.Errorf("failed to get chain ID: %v", err)
	}

	// Create a new instance of the GnosisSafe contract
	safeInstance, err := GnosisSafe.NewGnosisSafe(safeAddress, client)
	if err != nil {
		return fmt.Errorf("failed to create GnosisSafe instance: %v", err)
	}

	nonce := safeNonce
	if safeNonce == nil {
		// Fetch the current nonce from the Safe contract
		fetchedNonce, err := safeInstance.Nonce(&bind.CallOpts{})
		if err != nil {
			return fmt.Errorf("failed to fetch nonce from Safe contract: %v", err)
		}
		nonce = fetchedNonce
	} else {
		nonce = safeNonce
	}

	safeTransactionData := SafeTransactionData{
		To:             to.Hex(),
		Value:          value.String(),
		Data:           common.Bytes2Hex(data),
		Operation:      safeOperationType,
		SafeTxGas:      0,
		BaseGas:        0,
		GasPrice:       "0",
		GasToken:       NativeTokenAddress,
		RefundReceiver: NativeTokenAddress,
		Nonce:          nonce,
	}

	// Calculate SafeTxHash
	safeTxHash, err := CalculateSafeTxHash(safeAddress, safeTransactionData, chainID)
	if err != nil {
		return fmt.Errorf("failed to calculate SafeTxHash: %v", err)
	}

	// Sign the SafeTxHash
	signature, err := crypto.Sign(safeTxHash.Bytes(), key.PrivateKey)
	if err != nil {
		return fmt.Errorf("failed to sign SafeTxHash: %v", err)
	}

	// Adjust V value for Ethereum's replay protection
	signature[64] += 27

	// Convert signature to hex
	senderSignature := "0x" + common.Bytes2Hex(signature)

	// Prepare the request body
	requestBody := map[string]interface{}{
		"to":             safeTransactionData.To,
		"value":          safeTransactionData.Value,
		"data":           "0x" + safeTransactionData.Data,
		"operation":      int(safeTransactionData.Operation),
		"safeTxGas":      fmt.Sprintf("%d", safeTransactionData.SafeTxGas),
		"baseGas":        fmt.Sprintf("%d", safeTransactionData.BaseGas),
		"gasPrice":       safeTransactionData.GasPrice,
		"gasToken":       safeTransactionData.GasToken,
		"refundReceiver": safeTransactionData.RefundReceiver,
		"nonce":          fmt.Sprintf("%d", safeTransactionData.Nonce),
		"safeTxHash":     safeTxHash.Hex(),
		"sender":         key.Address.Hex(),
		"signature":      senderSignature,
		"origin":         fmt.Sprintf("{\"url\":\"%s\",\"name\":\"TokenSender Deployment\"}", safeApi),
	}

	// Marshal the request body to JSON
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return fmt.Errorf("failed to marshal request body: %v", err)
	}

	// Send the request to the Safe Transaction Service
	req, err := http.NewRequest("POST", safeApi, bytes.NewBuffer(jsonBody))
	if err != nil {
		return fmt.Errorf("failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")

	httpClient := &http.Client{}
	resp, err := httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to send request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	fmt.Println("Safe proposal created successfully")
	return nil
}

func CalculateSafeTxHash(safeAddress common.Address, txData SafeTransactionData, chainID *big.Int) (common.Hash, error) {
	domainSeparator := apitypes.TypedDataDomain{
		ChainId:           (*math.HexOrDecimal256)(chainID),
		VerifyingContract: safeAddress.Hex(),
	}

	typedData := apitypes.TypedData{
		Types: apitypes.Types{
			"EIP712Domain": []apitypes.Type{
				{Name: "chainId", Type: "uint256"},
				{Name: "verifyingContract", Type: "address"},
			},
			"SafeTx": []apitypes.Type{
				{Name: "to", Type: "address"},
				{Name: "value", Type: "uint256"},
				{Name: "data", Type: "bytes"},
				{Name: "operation", Type: "uint8"},
				{Name: "safeTxGas", Type: "uint256"},
				{Name: "baseGas", Type: "uint256"},
				{Name: "gasPrice", Type: "uint256"},
				{Name: "gasToken", Type: "address"},
				{Name: "refundReceiver", Type: "address"},
				{Name: "nonce", Type: "uint256"},
			},
		},
		Domain:      domainSeparator,
		PrimaryType: "SafeTx",
		Message: apitypes.TypedDataMessage{
			"to":             txData.To,
			"value":          txData.Value,
			"data":           "0x" + txData.Data,
			"operation":      fmt.Sprintf("%d", txData.Operation),
			"safeTxGas":      fmt.Sprintf("%d", txData.SafeTxGas),
			"baseGas":        fmt.Sprintf("%d", txData.BaseGas),
			"gasPrice":       txData.GasPrice,
			"gasToken":       txData.GasToken,
			"refundReceiver": txData.RefundReceiver,
			"nonce":          fmt.Sprintf("%d", txData.Nonce),
		},
	}

	typedDataHash, _, err := apitypes.TypedDataAndHash(typedData)
	if err != nil {
		return common.Hash{}, fmt.Errorf("failed to hash typed data: %v", err)
	}

	return common.BytesToHash(typedDataHash), nil
}
